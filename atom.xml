<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Sunshine</title>
  <icon>https://www.gravatar.com/avatar/81fa29e3a7c4a0e20b34f9a399347ccb</icon>
  <subtitle>鸣谢生命有你参与 笑纳我的邀请。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wuwii.com/"/>
  <updated>2019-12-15T15:02:50.230Z</updated>
  <id>http://blog.wuwii.com/</id>
  
  <author>
    <name>Kai Zhang</name>
    <email>im.zhangk@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 中的并发工具类</title>
    <link href="http://blog.wuwii.com/juc-utils.html"/>
    <id>http://blog.wuwii.com/juc-utils.html</id>
    <published>2018-05-20T02:08:03.000Z</published>
    <updated>2019-12-15T15:02:50.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><p><code>java.util.concurrent</code> 下提供了一些辅助类来帮助我们在并发编程的设计。</p><p>学习了 AQS 后再了解这些工具类，就非常简单了。</p><p><em>jdk 1.8</em></p><a id="more"></a><h3 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h3><p>在 <code>concurrent</code> 包下面提供了 <code>CountDownLatch</code> 类，它提供了计数器的功能，能够实现让一个线程等待其他线程执行完毕才能进入运行状态。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li><p>首先看下最关键的地方它的自定义同步器的实现，非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"><span class="comment">// 1. 初始化 state 资源变量</span></span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 尝试获取贡献模式下的资源，</span></span><br><span class="line">      <span class="comment">// 定义返回值小于 0 的时候获取资源失败</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">          <span class="comment">// 自旋。</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">int</span> nextc = c - <span class="number">1</span>; <span class="comment">// 每次释放资源，硬编码减一个资源</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 知道为 0 的时候才释放成功，也就是所有线程必须都执行释放操作说明才释放成功。</span></span><br><span class="line">           </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这里查看构造器的源码得知，<code>CountDownLatch</code> 内部使用的是 内部类<code>Sync</code> 继承了 <code>AQS</code> ，将我们传入进来的 <code>count</code> 数值当作 AQS state。感觉这个是不是和可重入锁实现是一样的，只不过开始指定了线程获取的锁的次数。</p><p>在上面我也发现了几个特点，第一次看这个代码其实还是不好理解，因为它相对前面的 AQS 和 TwinsLock 就是一个反着设计的代码：</p><ol><li>首先获取资源的时候，线程全部都是先进入等待队列，而且在这一步骤中，不改变 state 资源的数量；</li><li>释放资源的时候，每次固定减少一个资源，直到资源为 0 的时候才表示释放资源成功，所以加入我们有 5 个资源，但是只有四个线程执行，如果只释放四次（总共执行 countDown 四次），就永远也释放不成功，await 一直在阻塞。</li><li>经过上面的分析，发现了 state 的资源数量每次进行 <code>countDown</code> 都去减少一个，没有方法去增加数量，所以它是不可逆的，它的计数器是不可以重复使用的。</li></ol></li><li><p>看下 await 的实现，发现它最终实现的是 <code>doAcquireSharedInterruptibly</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 仔细看这个代码，和前面的共享模式中的 doAcquireShared 方法基本一摸一样，只不过是当它遇到线程中断信号的时候，立刻抛出中断异常，仔细想想也是的，比如，自己在这里等别人吃饭，不想等了，也懒得管别人做什么了，剩下的吃饭的事情也没必要继续下去了。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 需要注意的是它重写了尝试获取资源的方法，当资源全部消耗完，才能够让你去获取资源，现在才豁然开朗，await 阻塞的线程就是这么被唤醒的。</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>比如经典问题：</p><blockquote><p>有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？</p></blockquote><p>这个问题关键就是要知道<strong>四条线程何时执行完。</strong></p><p>下面是我的解决思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，</span></span><br><span class="line"><span class="comment"> * 所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by KronChan on 2018/5/14 17:00.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器，设置总量i，调用一次countDown(）方法后i的值会减1。</span></span><br><span class="line">        <span class="comment">// 在一个线程中如果调用了await()方法，这个线程就会进入到等待的状态，当参数i为0的时候这个线程才继续执行。</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br><span class="line">        Runnable thread1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"统计 C 盘大小"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计完成计数器 -1</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable thread2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"统计 D 盘大小"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable thread3 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"统计 E 盘大小"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable thread4 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">"统计 F 盘大小"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        pool.execute(thread1);</span><br><span class="line">        pool.execute(thread2);</span><br><span class="line">        pool.execute(thread3);</span><br><span class="line">        pool.execute(thread4);</span><br><span class="line">        <span class="comment">// 等待 i 值为 0 ，等待四条线程执行完毕。</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"统计完成"</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 线程协作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">// 必须同时到达barrier的线程个数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">// parties个线程到达barrier时，会执行的动作，会让到达屏障中的任意一个线程去执行这个动作。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">// 控制屏障的循环使用，它是可重复使用的，每次使用CyclicBarrier，本次所有线程同属于一代，即同一个Generation</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"> <span class="comment">// 处在等待状态的线程个数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h5 id="主要的方法"><a href="#主要的方法" class="headerlink" title="主要的方法"></a>主要的方法</h5><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数主要实现了，设置一组线程的数量，到达屏障时候的临界点，可以设置到达屏障的时候需要处理的动作，后面屏障允许它们通过。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存当前的generation</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generation broken，不允许使用，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 等待的计数器减一</span></span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="comment">// 如果计数器的 count 正好为0， 说明已经有parties个线程到达barrier了。执行预定的Runnable任务后，更新换代，准备下一次使用。</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果barrierCommand不为null，则执行该动作。</span></span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">// 唤醒所有等待线程，并更新generation，准备下一次使用</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，</span></span><br><span class="line">        <span class="comment">// 1. 有parties个线程到达barrier</span></span><br><span class="line">        <span class="comment">// 2. 当前线程被中断</span></span><br><span class="line">        <span class="comment">// 3. 超时</span></span><br><span class="line">        <span class="comment">// 直到上面三者之一发生，就唤醒所有线程继续执行下去</span></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是超时等待，则调用awati()进行等待；否则，调用awaitNanos()进行等待。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果等待过程中，线程被中断，通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// borken</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果generation已经换代，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放独占锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// barrier被broken后，调用breakBarrier方法，将generation.broken设置为true，并使用signalAll通知所有等待的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景，然后四条线程又可以分别去干自己的事情了。</p><p>现在我将上面的统计磁盘的任务 <code>CountDownLatch</code> 中改下，统计完统计最终后，每个线程要发出退出信号。</p><p>下面是我的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] drivers = &#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = drivers.length;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(length);</span><br><span class="line">        <span class="comment">// 如果线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(length, () -&gt; &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s 线程告诉你，统计完毕，待继续执行%n"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        Stream.of(drivers).forEach((d) -&gt; &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> StatisticsDemo(d, cyclicBarrier));</span><br><span class="line">        &#125;);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String driveName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDemo</span><span class="params">(String driveName, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.driveName = driveName;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                System.out.printf(<span class="string">"%s 线程统计 %s 盘大小%n"</span>, Thread.currentThread().getName(), driveName);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">"%s 准备退出%n"</span>, driveName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 线程统计 C 盘大小</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 线程统计 D 盘大小</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 线程统计 E 盘大小</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 线程统计 F 盘大小</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 线程告诉你，统计完毕，待继续执行</span><br><span class="line">F 准备退出</span><br><span class="line">E 准备退出</span><br><span class="line">D 准备退出</span><br><span class="line">C 准备退出</span><br></pre></td></tr></table></figure><h3 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h3><blockquote><p><code>Semaphore</code>（信号量）是用来控制同时访问特定资源的线程数量（许可证数），它通过协调各个线程，以保证合理的使用公共资源。</p></blockquote><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有公平锁的特性，<code>permits</code> 指定许可数量，就是资源数量 <code>state</code>。</p><h5 id="同步器的实现"><a href="#同步器的实现" class="headerlink" title="同步器的实现"></a>同步器的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">      Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">          setState(permits);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 非公平的方式获取共享锁</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// 获取资源数量</span></span><br><span class="line">              <span class="keyword">int</span> available = getState();</span><br><span class="line">              <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 本次请求获取锁需要的资源的数量</span></span><br><span class="line">              <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                  compareAndSetState(available, remaining)) <span class="comment">// 如果资源足够，尝试 CAS 获取锁</span></span><br><span class="line">                  <span class="keyword">return</span> remaining;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> current = getState();</span><br><span class="line">              <span class="keyword">int</span> next = current + releases; <span class="comment">// 释放锁的时候，返还资源</span></span><br><span class="line">              <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS 操作，避免其他的线程也在释放资源</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 减少资源数量</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> current = getState();</span><br><span class="line">              <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">              <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 清空资源，返回历史资源数量</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> current = getState();</span><br><span class="line">              <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">return</span> current;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * NonFair version</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">      NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">          <span class="keyword">super</span>(permits);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Fair version</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">      FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">          <span class="keyword">super</span>(permits);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// 同样的公平锁情况下，判断该线程前面有没有线程等待获取锁</span></span><br><span class="line">              <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">int</span> available = getState();</span><br><span class="line">              <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">              <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                  compareAndSetState(available, remaining))</span><br><span class="line">                  <span class="keyword">return</span> remaining;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="提供其他的方法"><a href="#提供其他的方法" class="headerlink" title="提供其他的方法"></a>提供其他的方法</h5><ul><li><code>availablePermits</code>：获取此信号量中当前可用的许可证数（还能有多少个线程执行）；</li><li><code>drainPermits</code>：立刻使用完所有可用的许可证；</li><li><code>reducePermits</code>：减少相应数量的许可证，是一个 <code>protected</code> 方法；</li><li><code>isFair</code>：是否是公平状态；</li><li><code>hasQueuedThreads</code>：等待队列中是否有线程，等待获取许可证；</li><li><code>getQueueLength</code>：等待队列中等待获取许可证的线程数量；</li><li><code>getQueuedThreads</code>：<code>protected</code> 方法，获取等待队列中的线程。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong><code>Semaphore</code>可以用于做流量控制，特别是公用资源有限的应用场景</strong>，比如我们有五台机器，有十名工人，每个工人需要一台机器才能工作，一名工人工作完了就可以休息了，机器让其他没工作过的工人使用。</p><p>下面是我的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        Semaphore machines = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i, machines)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Semaphore machines;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> worker;</span><br><span class="line"></span><br><span class="line">        Worker(<span class="keyword">int</span> worker, Semaphore semaphore) &#123;</span><br><span class="line">            <span class="keyword">this</span>.worker = worker;</span><br><span class="line">            <span class="keyword">this</span>.machines = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                machines.acquire();</span><br><span class="line">                System.out.printf(<span class="string">"工人 %d 开始使用机器工作了 %n"</span>, worker);</span><br><span class="line">                TimeUnit.SECONDS.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                System.out.printf(<span class="string">"工人 %d 干完活了，让出机器了%n"</span>, worker);</span><br><span class="line">                machines.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">工人 <span class="number">0</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">4</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">3</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">2</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">1</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">1</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">5</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">5</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">6</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">2</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">7</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">4</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">8</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">0</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">9</span> 开始使用机器工作了 </span><br><span class="line">工人 <span class="number">8</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">6</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">3</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">9</span> 干完活了，让出机器了</span><br><span class="line">工人 <span class="number">7</span> 干完活了，让出机器了</span><br></pre></td></tr></table></figure><p>虽然上面有 10 个工人（线程）一起并发，但是，它同时只有五个工人能够是执行的。</p><h3 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于两个工作线程间的数据交换。</p><p>具体上来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据进入到第二个线程中，第二个线程的数据进入到第一个线程中，这要就完成了一个“交易”的环节。</p><h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><p>源码很难看懂，主要还是</p><p><a href="https://www.jianshu.com/p/c523826b2c94" rel="external nofollow noopener noreferrer" target="_blank">【死磕Java并发】—–J.U.C之并发工具类：Exchanger</a></p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>Exchanger 可以用于遗传算法</strong>。遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据。</p><p>下面做一个卖书买书的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; EXCHANGER = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService POOLS = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        POOLS.execute(() -&gt; &#123;</span><br><span class="line">            String bookName = <span class="string">"浮生六记"</span>;</span><br><span class="line">            System.out.printf(<span class="string">"饭饭要卖一本%s。%n"</span>, bookName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String pay = EXCHANGER.exchange(bookName);</span><br><span class="line">                System.out.printf(<span class="string">"饭饭卖出一本%s赚了%s￥。%n"</span>, bookName, pay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"》》》》》》》》饭饭先到了交易地点 睡了 5 s，七巧来了"</span>);</span><br><span class="line">        System.out.println(<span class="string">"》》》》》》》》准备交易"</span>);</span><br><span class="line"></span><br><span class="line">        POOLS.execute(() -&gt; &#123;</span><br><span class="line">            String pay = <span class="string">"23"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String bookName = EXCHANGER.exchange(pay);</span><br><span class="line">                System.out.printf(<span class="string">"七巧付了%s￥买了一本%s。%n"</span>, pay, bookName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        POOLS.shutdown();</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (POOLS.isTerminated()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"交易结束！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">饭饭要卖一本浮生六记。</span><br><span class="line">》》》》》》》》饭饭先到了交易地点 睡了 <span class="number">5</span> s，七巧来了</span><br><span class="line">》》》》》》》》准备交易</span><br><span class="line">七巧付了<span class="number">23</span>￥买了一本浮生六记。</span><br><span class="line">饭饭卖出一本浮生六记赚了<span class="number">23</span>￥。</span><br><span class="line">交易结束！</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Exchanger</code>主要完成的是两个工作线程之间的数据交换，如果有一个线程没有执行 <code>exchange()</code>方法，则会一直等待。还可以设置最大等待时间<code>exchange（V v, TimeUnit unit）</code></p><h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><blockquote><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><p>CyclicBarrier还提供其他有用的方法，比如<code>getNumberWaiting</code>方法可以获得 <code>CyclicBarrier</code>阻塞的线程数量。<code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>《Java 并发编程的艺术》</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 下提供了一些辅助类来帮助我们在并发编程的设计。&lt;/p&gt;&lt;p&gt;学习了 AQS 后再了解这些工具类，就非常简单了。&lt;/p&gt;&lt;p&gt;&lt;em&gt;jdk 1.8&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程同步器 AQS</title>
    <link href="http://blog.wuwii.com/java-aqs.html"/>
    <id>http://blog.wuwii.com/java-aqs.html</id>
    <published>2018-05-18T03:11:03.000Z</published>
    <updated>2019-12-15T15:02:50.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="分析-AQS（队列同步器）"><a href="#分析-AQS（队列同步器）" class="headerlink" title="分析 AQS（队列同步器）"></a>分析 AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code> （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。</p><p><em>源码版本 Jdk 1.8</em></p><a id="more"></a><h4 id="怎么实现队列同步器"><a href="#怎么实现队列同步器" class="headerlink" title="怎么实现队列同步器"></a>怎么实现队列同步器</h4><p>同步器主要的使用方式是继承，子类实现它的部分方法来管理同步状态变量就可以了。</p><p>简单的说，同步器，使用一个状态 <code>state:int</code> 表示它的状态变化，如果有其他的锁需要使用 AQS ，需要操作这个状态变量，AQS 直接提供了三个方法供修改状态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取当前同步资源状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 设置当前同步状态</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">long</span> newState)</span> </span>&#123;</span><br><span class="line">       state = newState;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// CAS 操作 设置当前状态，该方法保证状态设置的原子性。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">       <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同步器是一个 CLH 队列（FIFO），队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> waitStatus;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>int waitStatus</td><td>表示节点的状态。其中包含的状态有：<br><code>CANCELLED</code>，值为1，表示当前的线程被取消；<br><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；<br><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition队列中；<br><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行；<br>值为0，表示当前节点在sync队列中，等待着获取锁。</td></tr><tr><td>Node prev</td><td><strong>前驱节点</strong>，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。</td></tr><tr><td>Node next</td><td><strong>后继节点</strong>。</td></tr><tr><td>Node nextWaiter</td><td>存储condition队列中的后继节点。</td></tr><tr><td>Thread thread</td><td>入队列时的当前线程。</td></tr></tbody></table><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/1.png" alt="image"></p><p>当前占有资源的节点就是头节点。</p><p>AQS 定义两种资源共享方式：</p><ul><li><code>Exclusive</code>：独占模式，又称排他模式，只能有一个线程占用资源，如 ReentrantLock；</li><li><code>Share</code>：共享模式，多个线程可以一起执行，同时占用资源。</li></ul><p>同步器对外部使用者提供五个方法，让锁使用资源的方法，主需要实现其中的部分方法，实现对共享资源的获取和释放就可以了。</p><ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行 CAS 设置同步状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           <span class="comment">// 上面判断如果为 true 的话，表示该等待的线程被中断过，但是等待过程中不能响应中断消息，获取资源后再自我中断，并且释放</span></span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试去获取资源状态，如果获取成功，返回 true，这里没有去实现方法，需要锁中自己去实现。</span></span><br><span class="line"><span class="comment">// 这里没有直接使用抽象方法，因为考虑到独占模式只实现 tryAcquire-tryRelease 这两个方法；而贡献模式只用实现tryAcquireShared-tryReleaseShared 这两个方法，避免都要去实现。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上一步中获取线程资源失败后，我们后面要做的就是让该线程加入到等待队列中。</span></span><br><span class="line"><span class="comment">// 为当前线程创建一个节点，同步器的模式为参数 mode 模式进入等待队列的队尾，并返回构造好的节点。</span></span><br><span class="line"><span class="comment">// @param mode 指定模式：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="comment">// 设置尾节点的时候需要线程安全，需要基于 CAS 操作设置尾节点，只有设置成功后当前节点才能正式与之前的尾节点进行联系。</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果队尾为 null 的时候，不能快速的入队操作，将使用 enq</span></span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个 node 节点 加入队尾，返回上一个尾节点。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// CAS自旋volatile变量</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="comment">// 队尾为 null 的话，证明该队列是空的，需要进行初始化；</span></span><br><span class="line">               <span class="comment">// 初始化一个队列，头节点为空的，尾节点指向头节点。</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="comment">// 直到拿到锁，</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 前面的步骤都是：当线程获取资源失败后，怎么样将线程放入到等待队列的队尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步就是当前线程放入到等待队列后，需要等待其他线程使用完资源释放，自己去获取资源。</span></span><br><span class="line"><span class="comment">// 如果获取到资源就返回</span></span><br><span class="line"><span class="comment">// 如果 node 节点的线程线程中断过，就返回 true</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 最终是否成功获得资源</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 标记线程是否被中断</span></span><br><span class="line">           <span class="comment">// 自旋锁</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获得指定节点的前驱节点 prev</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果该节点的前驱节点是 head 节点，则去尝试获取资源，</span></span><br><span class="line">                   <span class="comment">// 头节点拿到资源</span></span><br><span class="line">                   setHead(node); <span class="comment">// 拿到资源将该 Head 指向该节点，并且将线程的引用置 Null</span></span><br><span class="line">                   <span class="comment">// 由于只有一个线程能够获取到资源，因此设置头节点的时候，不需要 AQS 操作，直接设置即可。</span></span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC ，拿到资源后，将原头节点从队列中完全拿出来，让系统回收资源</span></span><br><span class="line">                   failed = <span class="keyword">false</span>; <span class="comment">// 标记已经成功拿到资源</span></span><br><span class="line">                   <span class="keyword">return</span> interrupted; </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 没有拿到资源，进入等待状态，并且检查是否被中断过。</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>; <span class="comment">// 线程中断过</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node); <span class="comment">// 出现异常，但没有成功获取获取到资源，取消该线程</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是去检查前面的线程是否是在等待准备运行，避免已经放弃了的线程节点，去寻找一个安全点（等待状态 waitStatus = 0）</span></span><br><span class="line"><span class="comment">// 前节点状态是SIGNAL时，当前线程需要阻塞，等待被它唤醒；</span></span><br><span class="line"><span class="comment">// 前节点状态是CANCELLED时，通过循环将当前节点之前所有取消状态的节点移出队列；</span></span><br><span class="line"><span class="comment">// 前节点状态是其他状态时，需要设置前节点为SIGNAL。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">            * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  上一步执行完毕 如果返回 true，表示自己要安心休息了，就开始执行这个步骤</span></span><br><span class="line"><span class="comment">// 返回 true ，表示当前线程中断过。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       LockSupport.park(<span class="keyword">this</span>); <span class="comment">// LockSupport.park 底层实现，让该线程进入等待状态</span></span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回检查当前线程是否被中断过</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结 <code>acquire</code> 流程：</p><ol><li>使用 <code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回；</li><li>如果上一步没有成功，<code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回；</li><li><code>acquireQueued()</code> 让线程进入等待队列中自旋，当轮到自己去获取资源的时候，采取尝试获取资源，如果被中断过，则返回 <code>true</code>，如果返回 <code>false</code> 则直接返回；</li><li>如果上一步返回 true，表示线程被中断过，但是在等待过程中是不响应的，获取到资源的时候，才去将本线程进行中断。</li></ol><h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试去释放节点</span></span><br><span class="line">           Node h = head; <span class="comment">// 找到头节点</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 判断该线程状态，主要是查看后面有没有节点需要它来唤醒的。</span></span><br><span class="line">               unparkSuccessor(h); <span class="comment">// 如果有线程需要它去唤醒，就去唤醒等待队列中的下一个线程</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;    </span><br><span class="line"><span class="comment">// 注意在独占模式下，这个方法是线程安全的，直接 setState(0) 释放资源即可。</span></span><br><span class="line"><span class="comment">// 释放完所有的资源（state = 0 ） ，返回  true。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 唤醒等待队列中的最前面节点的状态未取消的线程。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 如果当前等待线程的标志没有取消，则将线程节点的状态置 0，</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 升级为等待状态</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 开始去唤醒下一个节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断下个线程为空或者已经取消</span></span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 当下个节点是无效节点的时候，然后从尾节点开始遍历寻找有效节点，作为下个节点</span></span><br><span class="line">               <span class="comment">// 所以这里有个疑问，为什么要从尾节点开始遍历？</span></span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread); <span class="comment">// 唤醒下个线程，也只是唤醒一个有效线程状态</span></span><br><span class="line">       <span class="comment">// 既然参与竞争，它是等待队列中排在最前面的等待队列，经过前面的 shouldParkAfterFailedAcquire 调整，一定是 Head 的后继节点，下次自旋的时候，拿到资源的条件成立。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里为什么从开始尾节点遍历，<a href="https://my.oschina.net/xianggao/blog/532709" rel="external nofollow noopener noreferrer" target="_blank">参考文章</a></p><p>因为在CLH队列中的结点随时有可能被中断，<code>被中断的结点的waitStatus设置为CANCEL,而且它会被踢出CLH队列</code>，如何个踢出法，就是它的前趋结点的next并不会指向它，而是指向下一个非CANCEL的结点,而它自己的next指针指向它自己（将自己踢出，并让 GC 回收）。一旦这种情况发生，如何从头向尾方向寻找继任结点会出现问题，<code>因为一个CANCEL结点的next为自己，那么就找不到正确的继任接点</code>。</p><p><strong>总结下 release：</strong></p><p>需要独占模式中自定义的同步器子类去实现，用来释放资源，释放相应的资源，将 state 减少相应的数量即可，如果完全释放了资源，唤醒等待队列中有效的线程来获取资源。</p><ol><li>处理当前节点：非CANCELLED状态重置为0；</li><li>寻找下个节点：如果是CANCELLED状态，说明节点中途溜了，从队列尾开始寻找排在最前还在等着的节点</li><li>唤醒：利用LockSupport.unpark唤醒下个节点里的线程。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/2.jpg" alt="image"></p><ol><li>获取资源的时候，队列同步器中每个节点都是一个线程在进行自旋，如果该节点的前驱节点是头节点，它就可以去获取资源，退出自旋的时候，将本线程的节点设置成头节点；</li><li>释放资源的时候，将本线程的等待状态改成 0 （等待状态），然后让下一个小于 0 的有效节点的节点状态改成 0（等待状态），然后资源状态。</li><li>只有当前节点的前一个节点为 <code>SIGNAL</code> 时，才能当前节点才能被挂起。对线程的挂起及唤醒操作是通过使用 LockSupport 类的 <code>park/unpark</code> 实现的。</li></ol><h5 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h5><p>该方法提供了具备有超时功能的获取状态的调用，如果在指定的<code>nanosTimeout</code>内没有获取到状态，那么返回false，反之返回true。可以将该方法看做acquireInterruptibly的升级版，也就是在判断是否被中断的基础上增加了超时控制。<br>针对超时控制这部分的实现，主要需要计算出睡眠的delta，也就是间隔值。间隔可以表示为 nanosTimeout 等于原有<code>nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）</code>。如果nanosTimeout大于0，那么还需要使当前线程睡眠，反之则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 独占式超时获取资源</span></span><br><span class="line"><span class="comment">// 在指定时间段内获取资源，成功返回 true </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">long</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">// 计算最终超时事件</span></span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 独占模式加入到等待队列中</span></span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 自旋</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 没有获取到资源开始工作……</span></span><br><span class="line">               nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) <span class="comment">// 超时</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// &gt; 1000ns ，超时时间在 1000 ns 内 ，线程自旋中，否则线程进入阻塞状态。</span></span><br><span class="line">                   <span class="comment">// 设置线程还应该睡眠多长时间，避免等待时间过长期间的不断重试。</span></span><br><span class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">               <span class="comment">// 中断信号直接中断</span></span><br><span class="line">               <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/3.jpg" alt="image"></p><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 共享模式获取资源，获取成功则返回，获取失败进入同步等待队列中，整个过程忽略线程中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireShared(arg);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 需要自定义同步器去实现，</span></span><br><span class="line"><span class="comment">// 负值代表获取失败；</span></span><br><span class="line"><span class="comment">// 0 代表获取成功，刚好获取剩下的一个资源，没有资源再分配后面的线程；。</span></span><br><span class="line"><span class="comment">// 正数表示获取成功，返回剩余的资源数量。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取资源失败后，进入等待队列，自旋，直到获取资源才返回。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 设置共享模式</span></span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 设置是否获取资源成功标志</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 等待过程中，中断标志</span></span><br><span class="line">           <span class="comment">// 自旋</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获得前驱节点</span></span><br><span class="line">               <span class="comment">// 如果前驱节点是头节点，则取尝试获取资源</span></span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">long</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取资源成功后，就设置头节点为自己（node）</span></span><br><span class="line">                       setHeadAndPropagate(node, r); </span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted) <span class="comment">// 如果等待过程中出现线程中断就自己中断线程</span></span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 判断状态，找到安全点，进入等待状态，等待被唤醒，如果被中断，则补上中断标志</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed) <span class="comment">// 出现异常，取消该线程</span></span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 唤醒符合条件的其他线程</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">long</span> propagate)</span> </span>&#123;</span><br><span class="line">       Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">       setHead(node); <span class="comment">// 将头节点指向 node 节点</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 还有资源剩下，则继续唤醒后继节点的线程</span></span><br><span class="line">       <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">           (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           Node s = node.next;</span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">               doReleaseShared();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li><code>tryAcquireShared()</code>尝试获取资源，成功则直接返回；</li><li>失败则通过<code>doAcquireShared()</code> 进入等待队列 <code>park()</code>，直到被 <code>unpark()</code> / <code>interrupt()</code>并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol><h5 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 尝试释放资源</span></span><br><span class="line">           doReleaseShared(); <span class="comment">// 释放资源成功，唤醒后继节点取竞争资源</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 根据作者写这个方法的注释，表达的意思是释放一个或者以上的资源就返回 true，</span></span><br><span class="line"><span class="comment">// 但是实际情况下，ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以这个可以根据自己的实际情况进行更改的。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 唤醒后继 </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 自旋</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 判断后继节点是否需要运行</span></span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 将头节点设置成等待状态</span></span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   unparkSuccessor(h); <span class="comment">// 唤醒后继</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 如果头节点为等待状态了，则设置节点状态需要往后面的节点传播</span></span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Mutex（独占锁）"><a href="#Mutex（独占锁）" class="headerlink" title="Mutex（独占锁）"></a>Mutex（独占锁）</h4><p>具体是参考《Java 并发编程艺术》一书第五章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否是占有状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作全部依赖于AQS自定义的同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁是否占有状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义一个静态内部类继承类同步器并实现了独占模式的操作方法；</li><li>获取资源 tryAcquire 中，CAS 获取资源，获取成功返回 true；</li><li>释放资源 tryRelealse，将资源设置为0；</li></ol><p>测试一下（每过一秒打印一个结果）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mutex.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(j);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span></span><br><span class="line">------------</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------</span><br></pre></td></tr></table></figure><h4 id="TwinsLock（共享锁）"><a href="#TwinsLock（共享锁）" class="headerlink" title="TwinsLock（共享锁）"></a>TwinsLock（共享锁）</h4><p>具体是参考《Java 并发编程艺术》一书第五章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的同步器，能够有两个线程同时获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123; <span class="comment">// 将释放的资源返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondtion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondtion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TwinsLock 包含了一个自定义的同步器 sync，该同步器以共享方式获取同步状态。当 消耗资源<code>tryAcquireShared(int reduceCount)</code> 大于 或者等于 0 的时候，表示当前线程获取锁成功。</p><p>验证上面锁的正确性，就是要验证是否同一时刻有两个线程同时进行打印任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLockTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> TwinsLock();</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">4</span></span><br><span class="line">Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">7</span></span><br><span class="line">Thread-<span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在这个 AQS 同步器中我们时刻需要更改注意两个方面的问题：</p><ul><li><p>一是要去维护同步队列，更改同步器的资源状态变量，通过 <code>Unsafe</code> 提供原子操作 CAS；</p></li><li><p>二是底层还要去根据同步器状态变量去实现线程等待，线程唤醒的，它是通过 <code>LockSupport</code> 的 <code>park/unpark</code> 操作。<br>当然使用者不需要注意这些问题，代码已经把这些方法都已经封装好了，只要实现资源变量的变化的几个方法就可以了。</p></li><li><p>如果是要使用独占模式，只需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果只是要使用共享模式，需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="补充：CLH-队列锁"><a href="#补充：CLH-队列锁" class="headerlink" title="补充：CLH 队列锁"></a>补充：CLH 队列锁</h4><p>就是源码分析中那个同步队列，节点单位就是内部类 Node，获取锁的时候跟队列的头有关，释放锁主要删除头节点和从尾节点唤醒。它虽然保留了自旋操作，但是真实情况下，是阻塞了线程（LockSupport）。</p><h4 id="补充：CAS"><a href="#补充：CAS" class="headerlink" title="补充：CAS"></a>补充：CAS</h4><p>这部分参考文章 <a href="https://www.jianshu.com/p/e2179c74a2e4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" rel="external nofollow noopener noreferrer" target="_blank">认识非阻塞的同步机制CAS</a></p><blockquote><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论V值是否等于A值，都将返回V的原值。</p></blockquote><p>当多个线程尝试使用CAS同时更新一个变量，最终只有一个线程会成功，其他线程都会失败。但和使用锁不同，失败的线程不会被阻塞，而是被告之本次更新操作失败了，可以再试一次。此时，线程可以根据实际情况，继续重试或者跳过操作，大大减少因为阻塞而损失的性能。所以，CAS是一种乐观的操作，它希望每次都能成功地执行更新操作。</p><p><strong>AQS 中的 CAS 由 <code>Unsafe</code> 提供。</strong></p><h4 id="补充：自旋锁"><a href="#补充：自旋锁" class="headerlink" title="补充：自旋锁"></a>补充：自旋锁</h4><p>这部分参考文章 <a href="http://www.cnblogs.com/thomaschen750215/p/4122068.html" rel="external nofollow noopener noreferrer" target="_blank">CAS和自旋锁(spin lock)</a></p><blockquote><p>由于在多处理器系统环境中有些资源因为其有限性，有时需要互斥访问（mutual exclusion），这时会引入锁的机制，只有获取了锁的进程才能获取资源访问。即是每次只能有且只有一个进程能获取锁，才能进入自己的临界区，同一时间不能两个或两个以上进程进入临界区，当退出临界区时释放锁。设计互斥算法时总是会面临一种情况，即没有获得锁的进程怎么办？通常有2种处理方式。一种是没有获得锁的调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，这就是自旋锁，他不用将线城阻塞起来（NON-BLOCKING)；另一种是没有获得锁的进程就阻塞(BLOCKING)自己，请求OS调度另一个线程上处理器，这就是互斥锁。</p></blockquote><p>跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：</p><ul><li><strong>递归死锁</strong>：试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。</li><li><strong>过多占用cpu资源</strong>。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会</li></ul><p>​ 由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。</p><h4 id="补充：LockSupport"><a href="#补充：LockSupport" class="headerlink" title="补充：LockSupport"></a>补充：LockSupport</h4><p>具体内容请参考 <a href="https://www.jianshu.com/p/e3afe8ab8364" rel="external nofollow noopener noreferrer" target="_blank">LockSupport（park/unpark）源码分析</a></p><p><code>LockSupport.park()</code>和 <code>LockSupport.unpark(Thread thread)</code>调用的是 <code>Unsafe</code>中本地方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//park</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unpack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure><p><code>park</code> 函数是将当前调用Thread阻塞，而 <code>unpark</code> 函数则是将指定线程唤醒。</p><h3 id="ReentrantLock-独占锁"><a href="#ReentrantLock-独占锁" class="headerlink" title="ReentrantLock(独占锁)"></a>ReentrantLock(独占锁)</h3><p><a href="https://www.jianshu.com/p/fe027772e156" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/fe027772e156</a></p><p>其实 ReentantLock 的实现和上面的例子 <code>Mutex</code> 的差不多，不过它另外实现了可重入和公平锁两个部分。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">   <span class="keyword">int</span> c = getState();</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">           compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">       <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">       <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">       setState(nextc);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比非公平锁，它多了一个方法<code>hasQueuedPredecessors</code> 判断队列是否有排在前面的线程在等待锁，没有的话调用<code>compareAndSetState</code> 使用 CAS 的方式修改state，然后设置本线程为独占锁，并且它是可重入锁。</p><h3 id="ReentrantReadWriteLock（读写锁）"><a href="#ReentrantReadWriteLock（读写锁）" class="headerlink" title="ReentrantReadWriteLock（读写锁）"></a>ReentrantReadWriteLock（读写锁）</h3><p>首先来分析下读写锁的几个重要的特点：</p><ol><li>读写状态的设计；</li><li>写锁的获取与释放；</li><li>读锁的获取与释放；</li><li>锁降级的实现。</li></ol><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 提供公平锁，默认是非公平锁    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">       readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">       writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="读写状态设计"><a href="#读写状态设计" class="headerlink" title="读写状态设计"></a>读写状态设计</h4><p>在读写锁中最重要的就是Sync类，它继承自AQS，还记得吗，AQS使用一个int型来保存状态，状态在这里就代表锁，它提供了获取和修改状态的方法。可是，这里要实现读锁和写锁，只有一个状态怎么办？Doug Lea是这么做的，它把状态的高16位用作读锁，低16位用作写锁，所以无论是读锁还是写锁最多只能被持有65535次。所以在判断读锁和写锁的时候，需要进行位运算：</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/4.jpg" alt="image"></p><ol><li>由于读写锁共享状态，所以状态不为0，只能说明是有锁，可能是读锁，也可能是写锁；</li><li>读锁是高16为表示的，所以读锁加1，就是状态的高16位加1，低16位不变，所以要加的不是1，而是2^16，减一同样是这样。</li><li>写锁用低16位表示，要获得写锁的次数，要用状态&amp;2^16-1，结果的高16位全为0，低16位就是写锁被持有的次数。</li></ol><p>那它是怎么确定读写的各自的状态的了，是通过位运算符，假设当前同步状态值为 S，写状态等于 <code>S &amp; 0x0000FFFF</code>（只有 低 16 位），读状态等于 <code>S &gt;&gt;&gt; 16</code> （无符号补位右移 16 位）；这个时候写状态增加 1 时，等于 <code>S + 1</code>，当读状态增加 1，等于 <code>S + (1 &lt;&lt; 16)</code>，也就是 <code>S + 0x00010000</code>。</p><p>根据状态的划分可以得出一个结论： S 不等于 0 时，就是写状态计算公式 <code>S &amp; 0x0000FFFF == 0</code>，则读状态 <code>S &gt;&gt;&gt; 16 &gt; 0</code> 这个时候，读锁获取到了。</p><h4 id="同步器的设计"><a href="#同步器的设计" class="headerlink" title="同步器的设计"></a>同步器的设计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//ReentrantReadWriteLock的同步器</span></span><br><span class="line"><span class="comment">// 分别用子类来实现公平和非公平策略  </span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//高16位表示持有读锁的计数 </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;  </span><br><span class="line">      <span class="comment">//由于读锁用高位部分，读锁个数加1，其实是状态值加 2^16  </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT); </span><br><span class="line">      <span class="comment">// 所以读锁或者写锁分别最多线程数为 2^16 = 65535</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  </span><br><span class="line">      <span class="comment">// 低16位表示写锁计数，</span></span><br><span class="line">      <span class="comment">// 写锁的掩码，用于状态的低16位有效值 </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取读锁（共享锁）的数量</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  </span><br><span class="line">      <span class="comment">// 获取写锁（独占锁）的重入次数</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 每个线程特定的 read 持有计数。存放在ThreadLocal，不需要是线程安全的。</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">          <span class="comment">//使用id而不是引用是为了避免保留垃圾。注意这是个常量。  </span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> tid = Thread.currentThread().getId();  </span><br><span class="line">      &#125;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 采用继承是为了重写 initialValue 方法，这样就不用进行这样的处理： </span></span><br><span class="line"><span class="comment">       * 如果ThreadLocal没有当前线程的计数，则new一个，再放进ThreadLocal里。 </span></span><br><span class="line"><span class="comment">       * 可以直接调用 get。 </span></span><br><span class="line"><span class="comment">       * */</span>  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span>  </span></span><br><span class="line"><span class="class">          <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 当前线程持有的可重入读锁的数量，仅在构造方法和readObject(反序列化) </span></span><br><span class="line"><span class="comment">       * 时被初始化，当持有锁的数量为0时，移除此对象。 </span></span><br><span class="line"><span class="comment">       * 它存储了当前线程的 HoldCounter ，而HoldCounter中的count变量就是用来记录线程获得的写锁的个数。</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 最近一个成功获取读锁的线程的计数。这省却了ThreadLocal查找， </span></span><br><span class="line"><span class="comment">       * 通常情况下，下一个释放线程是最后一个获取线程。这不是 volatile 的， </span></span><br><span class="line"><span class="comment">       * 因为它仅用于试探的，线程进行缓存也是可以的 </span></span><br><span class="line"><span class="comment">       * （因为判断是否是当前线程是通过线程id来比较的）。 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;  </span><br><span class="line">     </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * firstReader是第一个获得读锁的线程； </span></span><br><span class="line"><span class="comment">       * firstReaderHoldCount是firstReader的重入计数； </span></span><br><span class="line"><span class="comment">       * 更准确的说，firstReader是最后一个把共享计数从0改为1，并且还没有释放锁。 </span></span><br><span class="line"><span class="comment">       * 如果没有这样的线程，firstReader为null; </span></span><br><span class="line"><span class="comment">       * firstReader不会导致垃圾堆积，因为在tryReleaseShared中将它置空了，除非 </span></span><br><span class="line"><span class="comment">       * 线程异常终止，没有释放读锁。 </span></span><br><span class="line"><span class="comment">       *  </span></span><br><span class="line"><span class="comment">       * 跟踪无竞争的读锁计数时，代价很低 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;  </span><br><span class="line"> </span><br><span class="line">      Sync() &#123;  </span><br><span class="line">          readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();  </span><br><span class="line">          setState(getState()); <span class="comment">// ensures visibility of readHolds  </span></span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 下面两个抽象方法用来实现读锁或者写锁是否需要阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;<span class="comment">//写锁是否需要阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;<span class="comment">//读锁是否需要阻塞</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 下面是非公平锁的实现</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">       <span class="comment">// 持有写锁可重入，不需要阻塞。</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据下一个节点是不是写锁（独占锁）确定它是否阻塞</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">            * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">            * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">            * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">            * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">            * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  AQS 提供的方法，判断下一个节点是独占锁</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node h, s;</span><br><span class="line">       <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           !s.isShared()         &amp;&amp;</span><br><span class="line">           s.thread != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 公平锁的实现，只要当前线程前面还有线程需要获取锁，都要进行阻塞。    </span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// AQS 提供的方法，和 ReentrantLock 里面同步锁实现一样的，判断该线程前面有没有线程在等待获取锁   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">       <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">       <span class="comment">// thread is first in queue.</span></span><br><span class="line">       Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">       Node h = head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">           ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>首先，写锁是一个可重入的排他锁，如果当前线程获取到了写锁，则增加写状态，如果读锁或者写锁已经被获取了，它则进入等待状态（写锁要确保写锁的操作对读锁可见）。</p><p>写锁和对外提供的方法和 ReentrantLock 一样的，这里主要去分析下它是怎么获取和释放资源的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 检查当前线程是不是独占模式</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// 计算释放后的资源数量</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 如果写锁都执行完了，释放写锁。</span></span><br><span class="line">    setState(nextc); <span class="comment">// 写入释放完资源的数量</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果 state 不为 0 表示锁已经分配出去了</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">//如果其他线程获取了写锁则获取失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires); <span class="comment">// 经过上面的检查后，表示写锁可以重入，并返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于要首次获取写锁，如果允许获取写锁， CAS 操作 获取独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取锁：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/5.png" alt="image"></p><p>获取锁的过程：</p><ol><li>首先获取写锁的数量；</li><li>判断写锁是否已经被获取了，如果已经获取了，就要做重入操作，将锁的资源数量加一，然后返回；如果是首次获取，就要进行 CAS 操作获取独占锁；</li></ol><p>释放锁的过程：</p><ol><li>计算如果释放完资源的数量；</li><li>如果剩下的资源数量为 0，则释放写锁；</li><li>如果剩下的资源数量不为 0，就将计算完的资源数量写入。</li></ol><h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是一个支持<strong>重入</strong>的<strong>共享锁</strong>，它能够被多个线程同时获取，当写锁的状态为 0 的时候，读锁总是获取成功的，并且增加读状态。这里比较复杂些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 先处理本地本地计数器</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否为第一个读线程firstReader</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">// 如果当前线程读锁重入次数为 1，再去释放这个线程，firstReader置空 ，否则减去重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若当前线程不是第一个读线程，那么首先会获取缓存计数器</span></span><br><span class="line">        <span class="comment">// 注：深层次去分析了源码发现 ：readHolds存储了每一个线程的HoldCounter，而HoldCounter中的count变量就是用来记录线程获得的写锁的个数。</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">            rh.tid != LockSupport.getThreadId(current)) <span class="comment">// 如果计数器为空或者 tid 不等于当前线程的 tid，则获取缓存计数器，</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="comment">// 如果当前线程的计数器数量小于或者等于 1 的时候，移除当前线程的计数器，</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 如果小于 1 的时候则抛出异常，</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正常获取到了当前线程计数器，则将计数数量减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当其他线程读锁也在释放读锁，AQS 可能失败所以自旋重试</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// 高 16 位 减一</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// AQS</span></span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IllegalMonitorStateException <span class="title">unmatchedUnlockException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IllegalMonitorStateException(</span><br><span class="line">        <span class="string">"attempt to unlock read lock, not locked by current thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current) <span class="comment">// 当没有线程持有写锁的时候就可以获取读锁</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 获取读锁失败后，线程进入等待队列</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁的数量</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 通过公平的策略判断，如果读锁不用阻塞</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;  <span class="comment">// 读锁数量没有超出上限</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 就去将读锁的资源数量加一，这个时候注意的是，由于读锁在高 16 位上。</span></span><br><span class="line">        <span class="comment">// 经过上一步，已经成功获取到读锁，后面进行相关设置</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current; <span class="comment">// 如果它是第一个获取到读锁的线程，则将 firstReader 指向它，并且计数读锁firstReader重入次数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++; <span class="comment">// 重入次数加一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于 不是 firstReader 读锁计数更新，更新当前线程的缓存</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁失败（阻塞或者数量上限或者 AQS 设置失败），重试，跟 tryAcquireShared 差不多的逻辑。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读读锁的时候需要注意<code>firstReader</code>，和 <code>HoldCounter</code> 这两个变量的变化就可以了：</p><ol><li>如果读锁没有被持有，那么每一个线程的 <code>HoldCounter</code> 变量中的 count 变量一定是为 0；</li><li>如果当前线程是第一个获取到读锁的线程，设置 <code>firstReader</code> 为当前线程，并且设置 <code>firstReadHoldCount</code>数量；</li><li>那么如果当前线程不是第一个获取读锁的线程，那么获取当前线程的 <code>HoldCounter</code>，获取 <code>count</code> 的值，判断它等不等于 0 ，如果等于 0 的话，表示当前线程没有获取读锁，那么可以从 <code>readHolds</code> 的管理中将它移除，</li></ol><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p><strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>主要是分析 AQS 源码的实现，了解到所有的同步类都是实现自定义的同步器 <code>sync</code> ，实现独占方法或者共享方法中的获取资源和释放资源方法供自己使用，同步器只要关注资源变量 state 的变化，对使用者非常友好，层次分明，而不需要关注队列和线程的阻塞的情况。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>《Java 并发编程的艺术》</li><li><a href="http://luojinping.com/2015/06/19/AbstractQueuedSynchronizer%E8%AF%A6%E8%A7%A3/" rel="external nofollow noopener noreferrer" target="_blank">AbstractQueuedSynchronizer详解</a></li><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" rel="external nofollow noopener noreferrer" target="_blank">Java并发之AQS详解</a></li><li><a href="https://www.jianshu.com/p/e2179c74a2e4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" rel="external nofollow noopener noreferrer" target="_blank">认识非阻塞的同步机制CAS</a></li><li><a href="http://www.cnblogs.com/thomaschen750215/p/4122068.html" rel="external nofollow noopener noreferrer" target="_blank">CAS和自旋锁(spin lock)</a></li><li><a href="https://www.jianshu.com/p/e3afe8ab8364" rel="external nofollow noopener noreferrer" target="_blank">LockSupport（park/unpark）源码分析</a></li><li><a href="https://blog.csdn.net/yuhongye111/article/details/39055531" rel="external nofollow noopener noreferrer" target="_blank">Java并发-ReentrantReadWriteLock源码分析</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;分析-AQS（队列同步器）&quot;&gt;&lt;a href=&quot;#分析-AQS（队列同步器）&quot; class=&quot;headerlink&quot; title=&quot;分析 AQS（队列同步器）&quot;&gt;&lt;/a&gt;分析 AQS（队列同步器）&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。&lt;/p&gt;&lt;p&gt;&lt;em&gt;源码版本 Jdk 1.8&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://blog.wuwii.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 hashCode 的一些研究</title>
    <link href="http://blog.wuwii.com/java-hashcode.html"/>
    <id>http://blog.wuwii.com/java-hashcode.html</id>
    <published>2018-05-15T14:08:03.000Z</published>
    <updated>2019-12-15T15:02:50.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h4 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h4><ol><li>hashcode 是干什么用的？</li><li>为什么要重写 hashcode 和 equals；</li><li>怎么去重写 hashcode；</li></ol><a id="more"></a><h4 id="hashcode-是什么"><a href="#hashcode-是什么" class="headerlink" title="hashcode 是什么"></a>hashcode 是什么</h4><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><blockquote><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。</p></blockquote><h5 id="Java-中的-hashCode"><a href="#Java-中的-hashCode" class="headerlink" title="Java 中的 hashCode"></a>Java 中的 hashCode</h5><p><code>hashCode</code>是 jdk 根据对象的地址算出来的一个 <strong>int</strong> 数字，即对象的哈希码值，代表了该对象在内存中的存储位置。</p><p>顶级父类 <code>Object</code> 提供获取 hashcode 的方法，调用的是本地的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Java 中的 hash 值主要用来干什么的？</p><p>hash 值主要是用来在散列存储结构（HashMap、HashTable、HashSet 等等）中确定对象的存储地址的，提高对象的查询效率，</p><h4 id="为什么要重写-hashcode-和-equals"><a href="#为什么要重写-hashcode-和-equals" class="headerlink" title="为什么要重写 hashcode 和 equals"></a>为什么要重写 hashcode 和 equals</h4><p>首先了解默认情况下的 hashcode 和 equals 方法是什么样：</p><ul><li>hashcode 根据内存地址换算出来一个值；</li><li>equals 判断对象的内存地址是否一样；</li></ul><p>但是大多数情况下，我们是需要判断它们的值是否是相等的情况。</p><p><code>Object.hashCode</code>的通用约定（<em>摘自《Effective Java》第45页</em>）</p><ol><li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li><li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li></ol><p><strong>如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）</strong>。</p><p>比如，我们经常用 String 类型作为 HashMap 的键，知道 HashMap 的键值存储的方式根据元素的 hashcode 求模来判断将元素放到哪个位置的。我们知道 hashMap 的特点是键值不能重复，这个重复就是先根据 hashcode 值判断在哪个位置，然后去链表中 用 equals 判断有没有相同。 如果不重写 hashcode 会造成一些意外的事件。</p><p>又引出例外一个问题了，比如我们用一个可变的对象作为 hashMap 的键值，并且重写了 hashcode 和 equals 方法，当我把一对键值（可变对象为键）装进 hashMap 后，又去改变了对象的某个属性（这个属性参与了 hashcode 的计算），然后就不能再用这个可变对象去操作已经插入到 hashMap 中的键值对了。</p><h4 id="怎么去重写-hashcode"><a href="#怎么去重写-hashcode" class="headerlink" title="怎么去重写 hashcode"></a>怎么去重写 hashcode</h4><p>从阅读 <code>String</code> 源码来分析比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;<span class="comment">// 主要是 String 对象是不可变的，可以使用一个变量存储起来，方便以后使用。</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"><span class="comment">// 计算每个字符的 ascii 参与到 hashcode 计算中，将前面计算的结果乘以 31 。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>提出问题，为什么要以 <em>31</em> 为权来计算 hashCode？</p><ol><li><p>因为 31 是素数，素数跟其他数相乘，更容易产生唯一性，所以 hash 冲突会小；</p></li><li><p>相乘的时候，数字太大，结果也是越大，很容易造成超出 int 值上限，导致数据丢失的情况，那为什么不是 17 了，参考StackOverflow上最高票的答案<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" rel="external nofollow noopener noreferrer" target="_blank">参考答案</a></p><blockquote><p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <code>31 * i == (i &lt;&lt; 5) - i</code>. Modern VMs do this sort of optimization automatically.</p></blockquote><p>解释说，因为虚拟机已经对<strong>移位和减法</strong>进行了优化，并且代替了乘法，性能会更好，因此 hash 的计算表达式是 ：<code>31 * i == (i &lt;&lt; 5) - i</code>。</p></li></ol><p>另外非常有意思的是还可以查看 <code>Long.java</code> 的 <code>hashCode()</code> 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Long 类型有 64 位，比 hash 的长度多了一倍，利用前 32 位 和后 32 位异或，尽可能的让更多的位置参与计算 hash 来保证唯一性。</p><p>最后可以参考 <code>IDEA</code> 默认自动生成的 hashCode 和 equals 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value1;</span><br><span class="line">    <span class="keyword">private</span> String value2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ObjectDemo that = (ObjectDemo) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value1 != <span class="keyword">null</span> ? !value1.equals(that.value1) : that.value1 != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> value2 != <span class="keyword">null</span> ? value2.equals(that.value2) : that.value2 == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = value1 != <span class="keyword">null</span> ? value1.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (value2 != <span class="keyword">null</span> ? value2.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><p><a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" rel="external nofollow noopener noreferrer" target="_blank">Why does Java’s hashCode() in String use 31 as a multiplier?</a></p></li><li><p><a href="https://blog.csdn.net/zknxx/article/details/53862572" rel="external nofollow noopener noreferrer" target="_blank">java为什么要重写hashCode和equals方法</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;hashcode 是干什么用的？&lt;/li&gt;&lt;li&gt;为什么要重写 hashcode 和 equals；&lt;/li&gt;&lt;li&gt;怎么去重写 hashcode；&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 中 LinkedList 源码阅读记录</title>
    <link href="http://blog.wuwii.com/java-linkedlist.html"/>
    <id>http://blog.wuwii.com/java-linkedlist.html</id>
    <published>2018-05-11T14:08:03.000Z</published>
    <updated>2019-12-15T15:02:50.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li>认识LinkedList 数据结构；</li><li>主要认识插入元素是怎么实现的；</li><li>遍历 LinkedList 的方法，以及具体实现；</li><li>与 ArrayList 对比。</li></ol><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul><li>jdk1.8.0_161</li></ul><a id="more"></a><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li>继承于<code>AbstractSequentialList</code>的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>实现 <code>List</code> 接口，能对它进行队列操作。</li><li>实现 <code>Deque</code> 接口，即能将LinkedList当作双端队列使用。</li><li>实现了<code>Cloneable</code>接口，即覆盖了函数<code>clone()</code>，能克隆。</li><li>实现<code>java.io.Serializable</code>接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li><li>是非同步的，非线程安全。</li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表中有多少个节点，默认为 0    </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList 是一个双向链表</strong>。内部类 <code>Node</code> 是 LinkedList 中的基本数据结构，包含当前节点值，上一个节点得引用，和下个节点的引用。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>比较简单，默认无参构造，和一个 <code>Collection</code> 参数的构造（ <em>将里面元素按顺序前后连接，修改节点个数，并且操作次数 + 1</em> ）。</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去为节点加</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的元素防止在链表的尾节点，以前的尾节点变成它前面的节点，如果上个尾节点为null，说明以前是的空链表。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index == size)</span><br><span class="line">          linkLast(element);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          linkBefore(element, node(index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// 双链表可以分别从 头节点 或者尾节点开始遍历，计算它是在前面一半，还是在后面的位置，决定遍历方式。</span></span><br><span class="line"><span class="comment">// 这也是LinkedList 为什么要使用双向链表，提升了使用游标操作链表的效率。</span></span><br><span class="line">      <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">          Node&lt;E&gt; x = first;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">              x = x.next;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Node&lt;E&gt; x = last;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">              x = x.prev;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert succ != null;</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">      succ.prev = newNode;</span><br><span class="line">      <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">          first = newNode;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          pred.next = newNode;</span><br><span class="line">      size++;</span><br><span class="line">      modCount++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>检查索引是否越界，虽然 ListedList 中没有索引概念；</li><li>如果 index 和 size 相同，则在尾节点上加上元素；</li><li>不相同的话，先去遍历链表查找到索引位置的节点，然后在它的前面插入节点。</li></ol><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><h5 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    checkElementIndex(index);  </span><br><span class="line">    <span class="keyword">return</span> node(index).item;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查索引越界；</li><li>跟上面的一样，查找该索引位置的节点，然后获取它的元素。</li></ol><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>其他的例如 <code>getFirst()</code>、<code>getLast()</code>。</p><h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> removeFirst();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移除头节点</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 参数 f 为头节点</span></span><br><span class="line"><span class="comment">// 将头节点指向 next 节点，如果 next节点 为 null 则链表 为 null ，链表大小减 1 ，修改次数记录加 1.</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">       <span class="keyword">final</span> E element = f.item;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">       f.item = <span class="keyword">null</span>;</span><br><span class="line">       f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">       first = next;</span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">           last = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           next.prev = <span class="keyword">null</span>;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="remove（int-index）"><a href="#remove（int-index）" class="headerlink" title="remove（int index）"></a>remove（int index）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    checkElementIndex(index);  </span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">        <span class="comment">// 如果本节点为头节点，头节点指向next</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是头节点，则将前节点和后节点连接起来，然后删掉本节点的引用 GC</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是尾节点，则将尾节点指向前节点</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 连接，双向链表，双方都有引用，删除自身的引用GC</span></span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除自身 GC</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 equals 找出 node，然后调用 unlink(Node&lt;E&gt; x)   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>有索引，第一件事去检查索引是否越界；</li><li>根据索引找出 node；</li><li>替换 node 的元素，返回 该索引位置 Node 的旧元素的值。</li><li>注意，Set 方法不增加LinkedList 的修改次数</li></ol><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:  </span></span><br><span class="line">       <span class="comment">// - helps a generational GC if the discarded nodes inhabit  </span></span><br><span class="line">       <span class="comment">//   more than one generation  </span></span><br><span class="line">       <span class="comment">// - is sure to free memory even if there is a reachable Iterator  </span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;  </span><br><span class="line">           Node&lt;E&gt; next = x.next;  </span><br><span class="line">           x.item = <span class="keyword">null</span>;  </span><br><span class="line">           x.next = <span class="keyword">null</span>;  </span><br><span class="line">           x.prev = <span class="keyword">null</span>;  </span><br><span class="line">           x = next;  </span><br><span class="line">       &#125;  </span><br><span class="line">       first = last = <span class="keyword">null</span>;  </span><br><span class="line">       size = <span class="number">0</span>;  </span><br><span class="line">       modCount++;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li>释放所有的元素，让他们直接无引用，垃圾回收器发现这些 node 元素是不可达的时候，释放内存。</li><li>数据恢复默认；修改次数记录加一。</li></ol><h4 id="实现-ListIterator"><a href="#实现-ListIterator" class="headerlink" title="实现 ListIterator"></a>实现 ListIterator</h4><p>非线程安全，并发下会快速失败。</p><p>继承 <code>Iterator</code>，<code>Iterator</code> 只能向后遍历和删除操作，<code>ListIterator</code> 额外添加了几个方法，主要实现以下几个功能：</p><ol><li>允许我们向前（previous）、向后（next）两个方向遍历 List;</li><li>使用迭代器遍历的时候，需要时刻知道游标索引的位置；</li><li>使用迭代器的时候，需要修改游标处的值，<code>remove</code>、<code>set</code>、<code>add</code> 这几个方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;<span class="comment">// 记录当前游标的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;<span class="comment">// 记录下一个节点，向前遍历的时候，一直和 lastReturned 相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;<span class="comment">// 记录当前游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//记录修改记录，用于快速失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned; </span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure><h4 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h4><p>jdk 1.8 中新增分割的迭代器，主要是 Jdk 1.8 中增加的并行处理的流运算，用到了可分割的迭代器。</p><p>LinkedList 主要只是实现默认的方法，进行分割，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LLSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UNIT = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;  <span class="comment">// batch array size increment</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BATCH = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;  <span class="comment">// max batch array size;</span></span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;E&gt; list; <span class="comment">// null OK unless traversed</span></span><br><span class="line">    Node&lt;E&gt; current;      <span class="comment">// current node; null until initialized</span></span><br><span class="line">    <span class="keyword">int</span> est;              <span class="comment">// size estimate; -1 until first needed</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount; <span class="comment">// initialized when est set</span></span><br><span class="line">    <span class="keyword">int</span> batch;            <span class="comment">// batch size for splits</span></span><br></pre></td></tr></table></figure><ol><li><p>使用<code>trySplit()</code> 对等分割，返回索引小的那部分 <code>Spliterator</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; p;</span><br><span class="line">    <span class="keyword">int</span> s = getEst();</span><br><span class="line">    <span class="comment">// 还能继续分割</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">1</span> &amp;&amp; (p = current) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点不为 null</span></span><br><span class="line">        <span class="comment">// batch 默认为0 ，</span></span><br><span class="line">        <span class="comment">// BATCH_UNIT 默认为 1024</span></span><br><span class="line">        <span class="comment">// 所以每一个后面的批处理，都会比前面多</span></span><br><span class="line">        <span class="keyword">int</span> n = batch + BATCH_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; s)</span><br><span class="line">            n = s;</span><br><span class="line">        <span class="comment">// 太大了执行最大批量处理</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; MAX_BATCH)<span class="comment">// 33554432</span></span><br><span class="line">            n = MAX_BATCH;</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将 list 的元素复制到数组中</span></span><br><span class="line">        <span class="keyword">do</span> &#123; a[j++] = p.item; &#125; <span class="keyword">while</span> ((p = p.next) != <span class="keyword">null</span> &amp;&amp; j &lt; n);</span><br><span class="line">        <span class="comment">// 如果初始的 list 大小大于 1024 ，将记录这些值，用于下次切割的时候使用</span></span><br><span class="line">        current = p;</span><br><span class="line">        batch = j;</span><br><span class="line">        est = s - j;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(a, <span class="number">0</span>, j, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进来的时候 est = -1 ，表示没有分割</span></span><br><span class="line"><span class="comment">// 其实就是返回 list 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getEst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="comment">// force initialization</span></span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;E&gt; lst;</span><br><span class="line">    <span class="keyword">if</span> ((s = est) &lt; <span class="number">0</span>) &#123; <span class="comment">// -1</span></span><br><span class="line">        <span class="keyword">if</span> ((lst = list) == <span class="keyword">null</span>)</span><br><span class="line">            s = est = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// list 不为 Null 我需要对自己的几个属性进行初始化值</span></span><br><span class="line">            expectedModCount = lst.modCount;</span><br><span class="line">            current = lst.first;</span><br><span class="line">            s = est = lst.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我初始化进来的时候，LLSpliterator 中的属性都是注释中的默认值，流程分析在上面中文注释中。</p><p><strong>所以当大小 小于 1024 的时候，分割没效果，还浪费了计算的性能。</strong></p><p><strong>还发现虽然它可以分割的，但是依然是非线程安全。</strong></p><ol start="2"><li><code>forEachRemaining(Consumer&lt;? super E&gt; action)</code> 批量消费，不能重复消费。</li><li><code>tryAdvance</code>，单个消费，从第一个开始消费，消费完移动节点，以后无法消费这个节点，成功消费返回 <code>true</code>。</li></ol></li></ol><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ol><li><p><code>indexof(Object)</code>,<code>lastindexof(Object)</code></p><p>（查找属性）找元素的索引，遍历查找，效率取决于离尾节点的位置；</p></li><li><p><code>peek</code>，（队列属性）查看头节点的元素；<code>element</code>方法也是一个意思，感觉有点重复的意思。</p></li><li><p><code>poll</code> ，（队列属性）删除头节点，并返回该节点的元素。</p></li><li><p><code>offer</code>，（队列属性），在尾节点添加，同 <code>offerFirst</code>；</p></li><li><p><code>removeFirstOccurrence(Object o)</code>，<code>removeLastOccurrence(Object o)</code> 删除第一次或者最后一次出现该元素的节点。</p></li></ol><h4 id="实现线程安全"><a href="#实现线程安全" class="headerlink" title="实现线程安全"></a>实现线程安全</h4><ol><li><code>Collections.synchronizedList(LinkedList);</code></li><li>锁</li></ol><h4 id="为什么-LinkedList-查找速度比-ArrayList-慢"><a href="#为什么-LinkedList-查找速度比-ArrayList-慢" class="headerlink" title="为什么 LinkedList 查找速度比 ArrayList 慢"></a>为什么 LinkedList 查找速度比 ArrayList 慢</h4><ol><li><code>ArrayList</code> 实现 了 <code>RandomAccess</code> 接口，并且它的数据结构是数组，空间连续的，可以使用索引下标直接访问元素；</li><li><code>LinkedList</code> 使用的是<code>get(int)</code> 方法，它需要从头节点或者尾节点开始遍历，如果要查找的元素的离头节点或者尾节点很远的时候，速度自然而然的慢下来了。</li></ol><h4 id="为什么-LinkedList-要使用迭代器而不使用-for-循环"><a href="#为什么-LinkedList-要使用迭代器而不使用-for-循环" class="headerlink" title="为什么 LinkedList 要使用迭代器而不使用 for 循环"></a>为什么 LinkedList 要使用迭代器而不使用 for 循环</h4><ol><li>迭代器的源码很好理解，就是一直使用游标获取下一个节点的值。</li><li>使用 for 循环的时候，我们肯定使用的是 <code>get(index)</code>这个方法，查看这个方法的源码发现，每次都是从头到尾遍历一遍，因为 LinkedLIst 是无序的，没有索引这个概念，只能够重新查找，当容量足够大后，这个性能损失得很明显。</li></ol><p>这样对比起来差距就很明显的。</p><p>最后还需要注意一点：<strong>使用迭代器循环 LinkedList 不比 for 循环的 ArrayList 的慢。</strong>这个可以下去做个测试，最好 10 万条。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Target &#123;</span><br><span class="line">        ARRAYLIST,</span><br><span class="line">        LINKEDLIST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">100000</span>;</span><br><span class="line">        List&lt;Integer&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">        List&lt;Integer&gt; lList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            aList.add(i);</span><br><span class="line">            lList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String msg;</span><br><span class="line">        Target target;</span><br><span class="line">        msg = <span class="string">"使用 for 循环 %s 十万次的时间 %s ms %n"</span>;</span><br><span class="line">        target = Target.ARRAYLIST;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aList.size(); i++) &#123;</span><br><span class="line">            aList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        target = Target.LINKEDLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lList.size(); i++) &#123;</span><br><span class="line">            lList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        msg = <span class="string">"使用 foreach 循环 %s 十万次的时间 %s ms%n"</span>;</span><br><span class="line">        target = Target.ARRAYLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer anAList : aList) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        target = Target.LINKEDLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer aLList : lList) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        msg = <span class="string">"使用 jdk stream api 循环 %s 十万次的时间 %s ms%n"</span>;</span><br><span class="line">        target = Target.ARRAYLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        aList.stream().forEach(l -&gt; &#123;&#125;);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        target = Target.LINKEDLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        lList.stream().forEach(l -&gt; &#123;&#125;);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        msg = <span class="string">"使用 jdk parallelStream api 循环 %s 十万次的时间 %s ms%n"</span>;</span><br><span class="line">        target = Target.ARRAYLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        aList.parallelStream().forEach(l -&gt; &#123;&#125;);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line"></span><br><span class="line">        target = Target.LINKEDLIST;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        lList.parallelStream().forEach(l -&gt; &#123;&#125;);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(msg, target, end - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="keyword">for</span> 循环 ARRAYLIST 十万次的时间 <span class="number">3</span> ms </span><br><span class="line">使用 <span class="keyword">for</span> 循环 LINKEDLIST 十万次的时间 <span class="number">5397</span> ms </span><br><span class="line">使用 foreach 循环 ARRAYLIST 十万次的时间 <span class="number">3</span> ms</span><br><span class="line">使用 foreach 循环 LINKEDLIST 十万次的时间 <span class="number">3</span> ms</span><br><span class="line">使用 jdk stream api 循环 ARRAYLIST 十万次的时间 <span class="number">41</span> ms</span><br><span class="line">使用 jdk stream api 循环 LINKEDLIST 十万次的时间 <span class="number">3</span> ms</span><br><span class="line">使用 jdk parallelStream api 循环 ARRAYLIST 十万次的时间 <span class="number">7</span> ms</span><br><span class="line">使用 jdk parallelStream api 循环 LINKEDLIST 十万次的时间 <span class="number">4</span> ms</span><br></pre></td></tr></table></figure><p>所以建议都是用 foreach （迭代器）进行没有性能损失，主要是有快速失败机制。jdk 1.8 的 stream 的表达式使用起来方便，稍微有些性能损失，按照使用环境考虑得失。</p><h4 id="LinkedList-插入速度一定比-ArrayList-快吗？"><a href="#LinkedList-插入速度一定比-ArrayList-快吗？" class="headerlink" title="LinkedList 插入速度一定比 ArrayList 快吗？"></a>LinkedList 插入速度一定比 ArrayList 快吗？</h4><p>不一定。</p><p><strong>首先我们需要说下 LinkedList 的插入步骤：</strong></p><ol><li>构建一个 Node 对象（需要浪费性能）；</li><li>寻址，找到对象要插入的位置（查找慢，如果插入的位置离头节点或者尾节点远，消耗的消费更多的性能）；</li><li>更改对象的引用地址，插入 node 对象。</li></ol><p><strong>再看下 ArrayList 的插入操作：</strong></p><ol><li>寻址，找到需要插入的位置；</li><li>如果需要扩容就扩容，如果不是插入到最后的位置，空出一个位置提供给插入的元素，需要批量往后移动数组的位置；</li><li>插入数据。</li></ol><p><strong>然后根据它们的特性：</strong></p><ol><li>LinkedList 插入的时候 为什么快，因为快在值需要改变前后 node 的引用地址就可以；</li><li>ArrayList 插入操作的时候为什么慢，因为慢在移动数组的位置上，移动的越多越慢。</li></ol><p><strong>问题就清楚了：</strong></p><ol><li>如果你确定了 ArrayList 不会扩容的情况下，又比较少移动元素（插入或者删除操作在比较后的位置），ArrayList 的插入或者删除操作效率其实比 LinkedList 还高。</li><li>如果 删除的元素在数据结构的非常靠前的位置，毫无疑问使用 LinkedList，</li><li>如果它们的操做位置都是<strong>在尾端进行插入操作</strong>，而且需要插入的<strong>元素的数量已知</strong>的情况下，用 ArrayList 效率会更高些，不需要构建 Node 对象，就少消耗了很多引用内存。</li><li>综合实际情况，还涉及到 ArrayList 扩容，插入元素是否在尾部等复杂因素。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;认识LinkedList 数据结构；&lt;/li&gt;&lt;li&gt;主要认识插入元素是怎么实现的；&lt;/li&gt;&lt;li&gt;遍历 LinkedList 的方法，以及具体实现；&lt;/li&gt;&lt;li&gt;与 ArrayList 对比。&lt;/li&gt;&lt;/ol&gt;&lt;h4 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;jdk1.8.0_161&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data JPA 中使用空间数据</title>
    <link href="http://blog.wuwii.com/jpa-spatial.html"/>
    <id>http://blog.wuwii.com/jpa-spatial.html</id>
    <published>2018-05-04T14:08:03.000Z</published>
    <updated>2019-12-15T15:02:50.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JPA 中使用空间数据字段的时候，出现了很多问题，中间走了好多弯路，这里记录下。</p><p>环境：</p><ul><li>Postgresql 9.5 + PostGIS</li><li>JPA</li><li>Spring 4.2</li></ul><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先需要检查项目中的 hibernate 的版本依赖的问题，因为我们需要使用 <code>hibernate-spatial</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Hibernate Spatial是对处理空间数据的一个Hibernate扩展 ，要想使用 Hibernate Spatial  就要引入JTS，完成Java 对几何图形对象的算法，">[1]</span></a></sup>的依赖包，它依赖 <code>hibernate-core 5.0</code> 以上的。还需要注意的一点是，我中间成了一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoSuchMethodError: org.hibernate.Session.getFlushMode()Lorg/hibernate/FlushMode;</span><br></pre></td></tr></table></figure><p>给出的解释是 :</p><blockquote><p><code>Hibernate 5.2</code> supports added in <code>Spring framework 4.3</code> , that its stable version will be available in next week. Spring 4.2 only supports Hibernate up to 5.1.</p></blockquote><p>项目中的 使用的是 <strong>Spring 4.2</strong> ，只好把 Hibernate 降级到 5.1。</p><ol><li><p>加入 <code>hibernate-spatial</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-spatial<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hibernate已经可以支持空间数据类型的数据操作了，可以实现空间数据入库到空间数据对象影射到java对象中（插入和查询方法），例如 equals,contains,disjoint,within 等等。</p></li><li><p>更改数据库方言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hibernate.dialect=org.hibernate.spatial.dialect.postgis.PostgisPG9Dialect</span><br></pre></td></tr></table></figure></li><li><p>空间数据库字段的映射：<br>这里只做了一个点的字段；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"geom"</span>, columnDefinition = <span class="string">"geometry(Point,4326)"</span>)</span><br><span class="line"><span class="keyword">private</span> Point geom;</span><br></pre></td></tr></table></figure></li><li><p>其余的 Repository 和 Service 跟普通无区别，</p><p>保存数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Geometry geom = <span class="keyword">new</span> WKTReader().read(<span class="string">"POINT (-122.2985 47.6448)"</span>);</span><br><span class="line">Point point = geom.getInteriorPoint();</span><br><span class="line">point.setSRID(<span class="number">4326</span>);</span><br><span class="line">reference.setGeom(point);</span><br><span class="line">repository.save(reference);</span><br></pre></td></tr></table></figure></li></ol><p>查询数据的时候，会出现一个问题，空间字段的json 中会出现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"coordinates" : &#123;</span><br><span class="line">  "envelope" : &#123;</span><br><span class="line">    "envelope" : &#123;</span><br><span class="line">      "envelope" : &#123;</span><br><span class="line">          ……</span><br></pre></td></tr></table></figure><p>这并不是我们需要的结果，原因是 <em>Jackson</em> 无法管理 <code>Point</code> 数据类型的序列化，需要我们自己定义它的序列化。</p><p>下面针对空间字段 <code>Point</code> 做一个序列化转换器。</p><ol><li><p>创建一个序列化转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointToJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Point value, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String jsonValue = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">double</span> lat = value.getY();</span><br><span class="line">                <span class="keyword">double</span> lon = value.getX();</span><br><span class="line">                <span class="comment">// wkt 格式，经纬度格式按照自己的需求</span></span><br><span class="line">                jsonValue = String.format(<span class="string">"POINT (%s %s)"</span>, lon, lat);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        gen.writeString(jsonValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们还需要从前端接收 geometry 字段的 wkt 形式的 json 字符串，这里需要反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Coordinate;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.GeometryFactory;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.Point;</span><br><span class="line"><span class="keyword">import</span> com.vividsolutions.jts.geom.PrecisionModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonToPointDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> GeometryFactory GEOMETRY_FACTORY = <span class="keyword">new</span> GeometryFactory(<span class="keyword">new</span> PrecisionModel(), <span class="number">4326</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">deserialize</span><span class="params">(JsonParser jp, DeserializationContext ctxt)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = jp.getText();</span><br><span class="line">            <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] coordinates = text.replaceFirst(<span class="string">"POINT ?\\("</span>, <span class="string">""</span>).replaceFirst(<span class="string">"\\)"</span>, <span class="string">""</span>).split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">double</span> lat = Double.parseDouble(coordinates[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">double</span> lon = Double.parseDouble(coordinates[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> GEOMETRY_FACTORY.createPoint(<span class="keyword">new</span> Coordinate(lat, lon));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在空间字段上配置自定义的序列化，最终结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"geom"</span>, columnDefinition = <span class="string">"geometry(Point,4326)"</span>)</span><br><span class="line"><span class="meta">@JsonSerialize</span>(using = PointToJsonSerializer.class)</span><br><span class="line"><span class="meta">@JsonDeserialize</span>(using = JsonToPointDeserializer.class)</span><br><span class="line"><span class="keyword">private</span> Point geom;</span><br></pre></td></tr></table></figure></li><li><p>测试向服务端传输数据和获取到的空间数据。</p><ul><li>返回的数据 <code>&quot;geom&quot;:&quot;POINT (-122.2985 47.6448)&quot;</code></li><li><p>传输数据 POST 提交：</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/junit-test/2.png" alt="image"></p></li></ul></li></ol><p>这样做的一个问题就是其余的例如线和多边形，要重新新建序列化代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这样就完成了自动的后端 <code>Geometry</code> 字段和 <code>wkt</code> 字符串数据的转换，同理其他形式的 ，例如<code>geojson</code> 格式一样可以进行自动转换。</p><p>补充一点，hibernate的postgis支持不是很好，国内资料比较少，很多需求或者问题都不是很好解决，而且它支持的 postgis 的函数库也比较少，所以可以使用原生 SQL 进行查询装载对象也是比较好的解决办法，例如使用 Mybatis。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="http://wiselyman.iteye.com/blog/2381465" rel="external nofollow noopener noreferrer" target="_blank">利用hibernate-spatial让Spring Data JPA支持空间数据</a></li><li><a href="https://stackoverflow.com/questions/27624940/map-a-postgis-geometry-point-field-with-hibernate-on-spring-boot" rel="external nofollow noopener noreferrer" target="_blank">Map a PostGIS geometry point field with Hibernate on Spring Boot</a><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">Hibernate Spatial是对处理空间数据的一个Hibernate扩展 ，要想使用 Hibernate Spatial 就要引入JTS，完成Java 对几何图形对象的算法，<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JPA 中使用空间数据字段的时候，出现了很多问题，中间走了好多弯路，这里记录下。&lt;/p&gt;&lt;p&gt;环境：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Postgresql 9.5 + PostGIS&lt;/li&gt;&lt;li&gt;JPA&lt;/li&gt;&lt;li&gt;Spring 4.2&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jpa" scheme="http://blog.wuwii.com/tags/jpa/"/>
    
      <category term="Spring" scheme="http://blog.wuwii.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>学习 Spring Boot：（二十九）Spring Boot Junit 单元测试</title>
    <link href="http://blog.wuwii.com/springboot-test.html"/>
    <id>http://blog.wuwii.com/springboot-test.html</id>
    <published>2018-04-26T14:08:03.000Z</published>
    <updated>2019-12-15T15:02:50.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JUnit 是一个<strong>回归测试框架</strong>，被开发者用于实施对应用程序的单元测试，加快程序编制速度，同时提高编码的质量。</p><p>JUnit 测试框架具有以下重要特性：</p><ul><li>测试工具</li><li>测试套件</li><li>测试运行器</li><li>测试分类</li></ul><a id="more"></a><h3 id="了解-Junit-基础方法"><a href="#了解-Junit-基础方法" class="headerlink" title="了解 Junit 基础方法"></a>了解 Junit 基础方法</h3><h4 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h4><p>在 <code>pom.xml</code> 中加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="创建测试类和测试方法"><a href="#创建测试类和测试方法" class="headerlink" title="创建测试类和测试方法"></a>创建测试类和测试方法</h4><ol><li>测试类的的命名规则一般是 <code>xxxTest.java</code> ；</li><li>测试类中测试的方法可以有前缀，这个看统一标准，所以有时候会发现别人的测试方法上有<code>test</code>前缀；</li><li>并且测试方法上加上注解 <code>@Test</code>。</li></ol><p>使用 IDEA 中，<strong>选中当前类名</strong>，使用快捷键 <code>ALT + ENTER</code>（WIN），向下选则 <code>Create Test</code> 回车，即可进入生成测试类的选项中，再次回车，就快速的生成测试类。</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/junit-test/1.png" alt="img"></p><p><code>OK</code> 完你会发现，生成的测试类在 <code>src/test</code> 目录下，测试类和源代码的<strong>包名</strong> 是一致的。生成后结果（注意下生成的方法名是不加 test）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JUnit中的注解"><a href="#JUnit中的注解" class="headerlink" title="JUnit中的注解"></a>JUnit中的注解</h4><ul><li><code>@BeforeClass</code>：针对所有测试，只执行一次，且必须为<code>static void</code></li><li><code>@Before</code>：初始化方法，执行当前测试类的每个测试方法前执行。</li><li><code>@Test</code>：测试方法，在这里可以测试期望异常和超时时间</li><li><code>@After</code>：释放资源，执行当前测试类的每个测试方法后执行</li><li><code>@AfterClass</code>：针对所有测试，只执行一次，且必须为<code>static void</code></li><li><code>@Ignore</code>：忽略的测试方法（只在测试类的时候生效，单独执行该测试方法无效）</li><li><code>@RunWith</code>:可以更改测试运行器 ，缺省值 <code>org.junit.runner.Runner</code></li></ul><p>一个单元测试类执行顺序为：</p><p><code>@BeforeClass</code> –&gt; <code>@Before</code> –&gt; <code>@Test</code> –&gt; <code>@After</code> –&gt; <code>@AfterClass</code></p><p>每一个测试方法的调用顺序为：</p><p><code>@Before</code> –&gt; <code>@Test</code> –&gt; <code>@After</code></p><h4 id="超时测试"><a href="#超时测试" class="headerlink" title="超时测试"></a>超时测试</h4><p>如果一个测试用例比起指定的毫秒数花费了更多的时间，那么 Junit 将自动将它标记为失败。<code>timeout</code> 参数和 <code>@Test</code>注释一起使用。现在让我们看看活动中的 <code>@test(timeout)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(timeout = <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"Complete"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面测试会失败，在一秒后会抛出异常 <code>org.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds</code></p><h4 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h4><p>你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。现在让我们看看活动中的 <code>@Test(expected)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = NullPointerException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNullException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会测试成功。</p><h4 id="套件测试"><a href="#套件测试" class="headerlink" title="套件测试"></a>套件测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskOneTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Task one do."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTwoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Task two do."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThreeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Task Three."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(Suite.class) <span class="comment">// 1. 更改测试运行方式为 Suite</span></span><br><span class="line"><span class="comment">// 2. 将测试类传入进来</span></span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;TaskOneTest.class, TaskTwoTest.class, TaskThreeTest.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuitTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试套件的入口类只是组织测试类一起进行测试，无任何测试方法，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h4><p>Junit 4 引入了一个新的功能<strong>参数化测试</strong>。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循 5 个步骤来创建<strong>参数化测试</strong>。</p><ul><li>用 <code>@RunWith(Parameterized.class)</code>来注释 test 类。</li><li>创建一个由 <code>@Parameters</code> 注释的<strong>公共的静态方法</strong>，它返回<strong>一个对象的集合(数组)</strong>来作为测试数据集合。</li><li>创建一个公共的构造函数，它接受和一行测试数据相等同的东西。</li><li>为每一列测试数据创建一个实例变量。</li><li>用实例变量作为测试数据的来源来创建你的测试用例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.更改默认的测试运行器为RunWith(Parameterized.class)</span></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.声明变量存放预期值和测试数据</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.声明一个返回值 为Collection的公共静态方法，并使用@Parameters进行修饰</span></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object[]&gt; param() &#123;</span><br><span class="line">        <span class="comment">// 这里我给出两个测试用例</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;&#123;<span class="string">"Mike"</span>, <span class="string">"Black"</span>&#125;, &#123;<span class="string">"Cilcln"</span>, <span class="string">"Smith"</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterTest</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 进行测试，发现它会将所有的测试用例测试一遍</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">        assertThat(<span class="string">"Mike Black"</span>, is(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hamcrest"><a href="#Hamcrest" class="headerlink" title="Hamcrest"></a>Hamcrest</h4><p>JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertThat( [actual], [matcher expected] );</span><br></pre></td></tr></table></figure><p>assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。</p><p>具体使用的一些匹配规则可以查看源码。</p><h3 id="Spring-Boot-中使用-JUnit"><a href="#Spring-Boot-中使用-JUnit" class="headerlink" title="Spring Boot 中使用 JUnit"></a>Spring Boot 中使用 JUnit</h3><p>Spring 框架提供了一个专门的测试模块（spring-test），用于应用程序的集成测试。 在 Spring Boot 中，你可以通过spring-boot-starter-test启动器快速开启和使用它。</p><h4 id="加入依赖-1"><a href="#加入依赖-1" class="headerlink" title="加入依赖"></a>加入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring-Boot-测试"><a href="#Spring-Boot-测试" class="headerlink" title="Spring Boot 测试"></a>Spring Boot 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取启动类，加载配置，确定装载 Spring 程序的装载方法，它回去寻找 主配置启动类（被 @SpringBootApplication 注解的）</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="comment">// 让 JUnit 运行 Spring 的测试环境， 获得 Spring 环境的上下文的支持</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImplTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-MVC-测试"><a href="#Spring-MVC-测试" class="headerlink" title="Spring MVC 测试"></a>Spring MVC 测试</h4><p>当你想对 <code>Spring MVC</code> 控制器编写单元测试代码时，可以使用<code>@WebMvcTest</code>注解。它提供了自配置的 <code>MockMvc</code>，可以不需要完整启动 <code>HTTP</code> 服务器就可以快速测试 <code>MVC 控制器</code>。</p><ol><li><p>需要测试的 Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/emp"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmployeeController</span><span class="params">(EmployeeService employeeService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.employeeService = employeeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;EmployeeResult&gt;&gt; listAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(employeeService.findEmployee());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 <code>MockMvc</code> 的测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(EmployeeController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController2Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据打桩，设置该方法返回的 body一直 是空的</span></span><br><span class="line">        Mockito.when(employeeService.findEmployee()).thenReturn(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/emp"</span>))</span><br><span class="line">                .andExpect(status().isOk()) <span class="comment">// 期待返回状态吗码200</span></span><br><span class="line">                <span class="comment">// JsonPath expression  https://github.com/jayway/JsonPath</span></span><br><span class="line">                <span class="comment">//.andExpect(jsonPath("$[1].name").exists()) // 这里是期待返回值是数组，并且第二个值的 name 存在，所以这里测试是失败的</span></span><br><span class="line">                .andDo(print()); <span class="comment">// 打印返回的 http response 信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@WebMvcTest</code>注解时，只有一部分的 Bean 能够被扫描得到，它们分别是：</p><ul><li><code>@Controller</code></li><li><code>@ControllerAdvice</code></li><li><code>@JsonComponent</code></li><li><code>Filter</code></li><li><code>WebMvcConfigurer</code></li><li><code>HandlerMethodArgumentResolver</code><br>其他常规的<code>@Component</code>（包括<code>@Service</code>、<code>@Repository</code>等）Bean 则不会被加载到 Spring 测试环境上下文中。<br>所以我在上面使用了数据打桩，<code>Mockito</code> 在这篇文章最后一节。</li></ul></li><li><p>我们也可以注入Spring 上下文的环境到 MockMvc 中，如下编写 <code>MockMvc</code> 的测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interface to provide configuration for a web application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 MVC 的环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(ctx).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc</span><br><span class="line">                .perform(get(<span class="string">"/emp"</span>) <span class="comment">// 测试的相对地址</span></span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8) <span class="comment">// accept response content type</span></span><br><span class="line">                )</span><br><span class="line">                .andExpect(status().isOk()) <span class="comment">// 期待返回状态吗码200</span></span><br><span class="line">                <span class="comment">// JsonPath expression  https://github.com/jayway/JsonPath</span></span><br><span class="line">                .andExpect(jsonPath(<span class="string">"$[1].name"</span>).exists()) <span class="comment">// 这里是期待返回值是数组，并且第二个值的 name 存在</span></span><br><span class="line">                .andDo(print()); <span class="comment">// 打印返回的 http response 信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是需要首先使用 <code>WebApplicationContext</code> 构建 <code>MockMvc</code>。</p></li></ol><h4 id="Spring-Boot-Web-测试"><a href="#Spring-Boot-Web-测试" class="headerlink" title="Spring Boot Web 测试"></a>Spring Boot Web 测试</h4><p>当你想启动一个完整的 HTTP 服务器对 Spring Boot 的 Web 应用编写测试代码时，可以使用<code>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</code>注解开启一个随机的可用端口。Spring Boot 针对 REST 调用的测试提供了一个 <code>TestRestTemplate</code> 模板，它可以解析链接服务器的相对地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController1Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResponseEntity&lt;List&gt; result = restTemplate.getForEntity(<span class="string">"/emp"</span>, List.class);</span><br><span class="line">        Assert.assertThat(result.getBody(), Matchers.notNullValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实之前上面的测试返回结果不是很正确，只能接收个List，给测试代码添加了不少麻烦，还好最终找到了解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于我返回的是 List 类型的，一直想不到办法解决，网上给出了解决办法，使用 exchange 函数代替</span></span><br><span class="line">    <span class="comment">//public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method,</span></span><br><span class="line">    <span class="comment">//HttpEntity&lt;?&gt; requestEntity, ParameterizedTypeReference&lt;T&gt; responseType,</span></span><br><span class="line">    <span class="comment">//Object... urlVariables) throws RestClientException &#123;</span></span><br><span class="line">    ParameterizedTypeReference&lt;List&lt;EmployeeResult&gt;&gt; type = <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;EmployeeResult&gt;&gt;() &#123;&#125;;</span><br><span class="line">    ResponseEntity&lt;List&lt;EmployeeResult&gt;&gt; result = restTemplate.exchange(<span class="string">"/emp"</span>, HttpMethod.GET, <span class="keyword">null</span>, type);</span><br><span class="line">    Assert.assertThat(result.getBody().get(<span class="number">0</span>).getName(), Matchers.notNullValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-JPA-测试"><a href="#Spring-Data-JPA-测试" class="headerlink" title="Spring Data JPA 测试"></a>Spring Data JPA 测试</h4><p>我们可以使用 <code>@DataJpaTest</code>注解表示只对 JPA 测试；<code>@DataJpaTest</code>注解它只扫描<code>@Entity</code>Bean 和装配 Spring Data JPA 存储库，其他常规的<code>@Component</code>（包括<code>@Service</code>、<code>@Repository</code>等）Bean 则不会被加载到 Spring 测试环境上下文。</p><p><code>@DataJpaTest</code> 还提供两种测试方式：</p><ol><li>使用内存数据库 <code>h2database</code>，Spring Data Jpa 测试默认采取的是这种方式；</li><li>使用真实环境的数据库。</li></ol><h5 id="使用内存数据库测试"><a href="#使用内存数据库测试" class="headerlink" title="使用内存数据库测试"></a>使用内存数据库测试</h5><ol><li><p>默认情况下，<code>@DataJpaTest</code>使用的是内存数据库进行测试，你无需配置和启用真实的数据库。只需要在 <code>pom.xml</code> 配置文件中声明如下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>gradle file:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile(<span class="string">'com.h2database:h2'</span>)</span><br></pre></td></tr></table></figure></li><li><p>编写测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        EmployeeDetail detail = <span class="keyword">new</span> EmployeeDetail();</span><br><span class="line">        detail.setName(<span class="string">"kronchan"</span>);</span><br><span class="line">        detail.setAge(<span class="number">24</span>);</span><br><span class="line">        employee.setDetail(detail);</span><br><span class="line">        assertThat(detail.getName(), Matchers.is(employeeDao.save(employee).getDetail().getName()));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="使用真实数据库测试"><a href="#使用真实数据库测试" class="headerlink" title="使用真实数据库测试"></a>使用真实数据库测试</h5><p>如要需要使用真实环境中的数据库进行测试，需要替换掉默认规则，使用<code>@AutoConfigureTestDatabase(replace = Replace.NONE)</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="comment">// 加入 AutoConfigureTestDatabase 注解</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase</span>(replace = AutoConfigureTestDatabase.Replace.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        EmployeeDetail detail = <span class="keyword">new</span> EmployeeDetail();</span><br><span class="line">        detail.setName(<span class="string">"kronchan"</span>);</span><br><span class="line">        detail.setAge(<span class="number">24</span>);</span><br><span class="line">        employee.setDetail(detail);</span><br><span class="line">        assertThat(detail.getName(), Matchers.is(employeeDao.save(employee).getDetail().getName()));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><p>执行上面的新增数据的测试，发现测试通过，但是数据库却并没有新增数据。<strong>默认情况下，在每个 JPA 测试结束时，事务会发生回滚。这在一定程度上可以防止测试数据污染数据库。</strong></p><p>如果你不希望事务发生回滚，你可以使用<code>@Rollback(false)</code>注解，该注解可以标注在类级别做全局的控制，也可以标注在某个特定不需要执行事务回滚的方法级别上。</p><p>也可以显式的使用注解 <code>@Transactional</code> 设置事务和事务的控制级别，放大事务的范围。</p><h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h3><p>这部分参考 <a href="http://sunxiang0918.cn/2016/03/28/%E4%BD%BF%E7%94%A8Mockito%E5%92%8CSpringTest%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="external nofollow noopener noreferrer" target="_blank">使用Mockito和SpringTest进行单元测试</a></p><p><code>JUnit</code>和<code>SpringTest</code>,基本上可以满足绝大多数的单元测试了，但是，由于现在的系统越来越复杂，相互之间的依赖越来越多。特别是微服务化以后的系统，往往一个模块的代码需要依赖几个其他模块的东西。因此，在做单元测试的时候，往往很难构造出需要的依赖。一个单元测试，我们只关心一个小的功能，但是为了这个小的功能能跑起来，可能需要依赖一堆其他的东西，这就导致了单元测试无法进行。所以，我们就需要再测试过程中引入<code>Mock</code>测试。</p><p>所谓的<code>Mock</code>测试就是在测试过程中，对于一些不容易构造的、或者和这次单元测试无关但是上下文又有依赖的对象，用一个虚拟的对象（Mock对象）来模拟，以便单元测试能够进行。</p><p>比如有一段代码的依赖为：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/mock/1.jpg" alt="img"><br>当我们要进行单元测试的时候，就需要给<code>A</code>注入<code>B</code>和<code>C</code>,但是<code>C</code>又依赖了<code>D</code>，<code>D</code>又依赖了<code>E</code>。这就导致了，A的单元测试很难得进行。<br>但是，当我们使用了Mock来进行模拟对象后，我们就可以把这种依赖解耦，只关心A本身的测试，它所依赖的B和C，全部使用<strong>Mock出来</strong>的对象，并且给<code>MockB</code>和<code>MockC</code>指定一个明确的行为。就像这样：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/mock/2.jpg" alt="img"></p><p>因此，当我们使用Mock后，对于那些难以构建的对象，就变成了个模拟对象，只需要提前的做<code>Stubbing</code>（桩）即可，所谓做桩数据，也就是告诉Mock对象，当与之交互时执行何种行为过程。比如当调用B对象的b()方法时，我们期望返回一个<code>true</code>，这就是一个设置桩数据的预期。</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><a href="http://www.importnew.com/21540.html" rel="external nofollow noopener noreferrer" target="_blank">Mockito 简明教程</a></p><h4 id="Spring-Boot-中使用"><a href="#Spring-Boot-中使用" class="headerlink" title="Spring Boot 中使用"></a>Spring Boot 中使用</h4><p>上面的 <code>Spring MVC 测试</code> 中也使用到了 <code>Mockito</code>，</p><p><code>spring-boot-starter-test</code> 自带了 <code>mockito-core</code>。</p><h5 id="基础业务"><a href="#基础业务" class="headerlink" title="基础业务"></a>基础业务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>, length = <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id, String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.getOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateUsername</span><span class="params">(Long id, String username)</span> </span>&#123;</span><br><span class="line">        User user = findOne(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        <span class="keyword">return</span> userRepository.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IUserServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Mock</span></span><br><span class="line">    <span class="keyword">private</span> IUserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对所有注解了@Mock的对象进行模拟</span></span><br><span class="line">        <span class="comment">// MockitoAnnotations.initMocks(this);</span></span><br><span class="line">        <span class="comment">// 不使用注解，可以对单个对象进行 mock</span></span><br><span class="line">        userRepository = Mockito.mock(IUserRepository.class);</span><br><span class="line">        <span class="comment">// 构造被测试对象</span></span><br><span class="line">        userService = <span class="keyword">new</span> UserServiceImpl(userRepository);</span><br><span class="line">        <span class="comment">// 打桩，构建当 userRepository的 getOne 函数执行参数为 1的时候，设置返回的结果 User</span></span><br><span class="line">        Mockito.when(userRepository.getOne(<span class="number">1L</span>)).thenReturn(<span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"kronchan"</span>));</span><br><span class="line">        <span class="comment">// 打桩，构建当 userRepository的 getOne 函数执行参数为 2的时候，设置返回的结果 null</span></span><br><span class="line">        Mockito.when(userRepository.getOne(<span class="number">2L</span>)).thenReturn(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 打桩，构建当 userRepository的 getOne 函数执行参数为 3的时候，设置结果抛出异常</span></span><br><span class="line">        Mockito.when(userRepository.getOne(<span class="number">3L</span>)).thenThrow(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"The id is not support"</span>));</span><br><span class="line">        <span class="comment">// 打桩，当 userRepository.updateUser 执行任何User类型的参数，返回的结果都是true</span></span><br><span class="line">        Mockito.when(userRepository.updateUser(Mockito.any(User.class))).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUsernameSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> userId = <span class="number">1L</span>;</span><br><span class="line">        String newUsername = <span class="string">"new kronchan"</span>;</span><br><span class="line">        <span class="comment">// 测试某个 service 的方法</span></span><br><span class="line">        <span class="keyword">boolean</span> updated = userService.updateUsername(userId, newUsername);</span><br><span class="line">        <span class="comment">// 检查结果</span></span><br><span class="line">        Assert.assertThat(updated, Matchers.is(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// Verifies certain behavior &lt;b&gt;happened once&lt;/b&gt;.</span></span><br><span class="line">        <span class="comment">// mock对象一旦创建，就会自动记录自己的交互行为。通过verify(mock).someMethod()方法，来验证方法是否被调用。</span></span><br><span class="line">        <span class="comment">// 验证调用上面的service 方法后是否 userRepository.getOne(1L) 调用过，</span></span><br><span class="line">        Mockito.verify(userRepository).getOne(userId);</span><br><span class="line">        <span class="comment">// 有条件可以测试下没有被调用过的方法：</span></span><br><span class="line">        <span class="comment">//   Mockito.verify(userRepository).deleteById(userId);</span></span><br><span class="line">        <span class="comment">//   则会测试失败：</span></span><br><span class="line">        <span class="comment">//    Wanted but not invoked:</span></span><br><span class="line">        <span class="comment">//      userRepository.deleteById(1L);</span></span><br><span class="line">        <span class="comment">//    However, there were exactly 2 interactions with this mock:</span></span><br><span class="line">        <span class="comment">//      userRepository.getOne(1L);</span></span><br><span class="line">        <span class="comment">//      userRepository.updateUser(</span></span><br><span class="line">        <span class="comment">//         User(id=1, username=new kronchan, password=null, createDate=null)</span></span><br><span class="line">        <span class="comment">//      );</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  updateUsername 函数中我们调用了已经打桩了的其他的函数，现在我们来验证进入其他函数中的参数</span></span><br><span class="line">        <span class="comment">//构造参数捕获器，用于捕获方法参数进行验证</span></span><br><span class="line">        ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);</span><br><span class="line">        <span class="comment">// 验证updateUser方法是否被调用过，并且捕获入参</span></span><br><span class="line">        Mockito.verify(userRepository).updateUser(userCaptor.capture());</span><br><span class="line">        <span class="comment">// 获取参数 updatedUser</span></span><br><span class="line">        User updatedUser = userCaptor.getValue();</span><br><span class="line">        <span class="comment">// 验证入参是否是预期的</span></span><br><span class="line">        Assert.assertThat(updatedUser.getUsername(), Matchers.is(newUsername));</span><br><span class="line">        <span class="comment">//保证这个测试用例中所有被Mock的对象的相关方法都已经被Verify过了</span></span><br><span class="line">        Mockito.verifyNoMoreInteractions(userRepository);</span><br><span class="line">        <span class="comment">// 如果有一个交互，但是我们没有verify ，则会报错，</span></span><br><span class="line">        <span class="comment">//      org.mockito.exceptions.verification.NoInteractionsWanted:</span></span><br><span class="line">        <span class="comment">//      No interactions wanted here:</span></span><br><span class="line">        <span class="comment">//      -&gt; at com.wuwii.service.IUserServiceTest.testUpdateUsernameSuccess(IUserServiceTest.java:74)</span></span><br><span class="line">        <span class="comment">//      But found this interaction on mock 'iUserRepository':</span></span><br><span class="line">        <span class="comment">//      -&gt; at com.wuwii.service.impl.UserServiceImpl.findOne(UserServiceImpl.java:21)</span></span><br><span class="line">        <span class="comment">//      ***</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUsernameFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> userId = <span class="number">2L</span>;</span><br><span class="line">        String newUsername = <span class="string">"new kronchan"</span>;</span><br><span class="line">        <span class="comment">// 没有经过 mock 的 updateUser 方法，它返回的是 false</span></span><br><span class="line">        <span class="keyword">boolean</span> updated = userService.updateUsername(userId, newUsername);</span><br><span class="line">        Assert.assertThat(updated, Matchers.not(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">//验证userRepository的getOne(2L)这个方法是否被调用过，（这个是被测试过的，此步骤通过）</span></span><br><span class="line">        Mockito.verify(userRepository).getOne(<span class="number">2L</span>);</span><br><span class="line">        <span class="comment">// 验证 userRepository 的 updateUser(null)这个方法是否被调用过，（这个没有被测试过，此步骤不通过）</span></span><br><span class="line">        <span class="comment">//Mockito.verify(userRepository).updateUser(null);</span></span><br><span class="line">        Mockito.verifyNoMoreInteractions(userRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><h6 id="创建MOCK的对象"><a href="#创建MOCK的对象" class="headerlink" title="创建MOCK的对象"></a>创建MOCK的对象</h6><p>我需要对 <code>userService</code> 进行测定，就需要模拟 <code>userRepository</code> 对象。</p><p>我在 <code>setUp()</code> 方法中，模拟对象并打桩。</p><p>模拟对象有两种方式：</p><ol><li>对注解了@Mock的对象进行模拟 <code>MockitoAnnotations.initMocks(this);</code></li><li>对单个对象手动 mock ：<code>userRepository = Mockito.mock(IUserRepository.class);</code></li></ol><p>数据打桩，除了上面我代码上用的几个方法，还有非常多的方法，具体可以在使用的时候看到，主要分下面几种：</p><ol><li><p>最基本的用法就是调用 <code>when</code>以及<code>thenReturn</code>方法了。他们的作用就是指定当我们调用被代理的对象的某一个方法以及参数的时候，返回什么值。</p></li><li><p>提供参数匹配器，灵活匹配参数。<code>any()</code>、<code>any(Class&lt;T&gt; type)</code>、<code>anyBoolean()</code>、<code>anyByte()</code>、<code>anyChar()</code>、<code>anyInt()</code>、<code>anyLong()</code>等等，它支持复杂的过滤，可以使用正则 <code>Mockito.matches(&quot;.*User$&quot;))</code>，开头结尾验证<code>endsWith(String suffix)</code>，<code>startsWith(String prefix)</code>、判空验证<code>isNotNull()</code> <code>isNull()</code><br>也还可以使用 argThat(ArgumentMatcher<t>matcher)，如：<code>ArgumentMatcher</code>只有一个方法<code>boolean matches(T argument);</code>传入入参，返回一个boolean表示是否匹配。</t></p><p><code>Mockito.argThat(argument -&gt; argument.getUsername.length() &gt; 6;</code></p></li><li><p><em>Mockito</em>还提供了两个表示行为的方法：<code>thenAnswer(Answer&lt;?&gt; answer);</code>、<code>thenCallRealMethod();</code>,分别表示自定义处理调用后的行为，以及调用真实的方法。这两个方法在有些测试用例中还是很有用的。</p></li><li><p>对于同一个方法，<em>Mockito</em>可以是顺序与次数关心的。也就是说可以实现同一个方法，第一次调用返回一个值，第二次调用返回一个值，甚至第三次调用抛出异常等等。只需要连续的调用<code>thenXXXX</code>即可。</p></li><li><p>如果为一个返回为<em>Void</em>的方法设置桩数据。上面的方法都是表示的是有返回值的方法，而由于一个方法没有返回值，因此我们不能调用<code>when</code>方法(编译器不允许)。因此，对于无返回值的方法，<em>Mockito</em>提供了一些列的<code>doXXXXX</code>方法，比如：<code>doAnswer(Answer answer)</code>、<code>doNothing()</code>、<code>doReturn(Object toBeReturned)</code>、<code>doThrow(Class&lt;? extends Throwable&gt; toBeThrown)</code>、<code>doCallRealMethod()</code>。他们的使用方法其实和上面的<code>thenXXXX</code>是一样的，但是<code>when</code>方法传入的是<em>Mock的对象</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对void的方法设置模拟*/</span></span><br><span class="line">Mockito.doAnswer(invocationOnMock -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"进入了Mock"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;).when(fileRecordDao).insert(Mockito.any());</span><br></pre></td></tr></table></figure><p>当 Mockito 监视一个真实的对象的时候，我们也可以模拟这个对象的方法返回我们设置的期望值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List spy = spy(<span class="keyword">new</span> LinkedList());  </span><br><span class="line">List spy = spy(<span class="keyword">new</span> LinkedList());  </span><br><span class="line"><span class="comment">// IndexOutOfBoundsException (the list is yet empty)  </span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);  </span><br><span class="line"><span class="comment">// You have to use doReturn() for stubbing  </span></span><br><span class="line">doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>when方法参数中<code>spy.get(0)</code>，调用的是真实list对象的get(0)，这会产生 <code>IndexOutOfBoundsException</code>异常，所以这时需要用到 <code>doReturn</code> 方法来设置返回值。</p></li></ol><h6 id="验证测试方法的结果"><a href="#验证测试方法的结果" class="headerlink" title="验证测试方法的结果"></a>验证测试方法的结果</h6><p>使用断言语句检查结果。</p><h6 id="验证MOCK对象的调用"><a href="#验证MOCK对象的调用" class="headerlink" title="验证MOCK对象的调用"></a>验证MOCK对象的调用</h6><p>其实，在这里我们如果只是验证方法结果的正确的话，就非常简单，但是，在复杂的方法调用堆栈中，往往可能出现结果正确，但是过程不正确的情况。比如，<code>updateUserName</code>方法返回false是有两种可能的，一种可能是用户没有找到，还有一种可能就是<code>userRepository.updateUser(userPO)</code>返回false。因此，如果我们只是使用<code>Assert.assertFalse(updated);</code>来验证结果，可能就会忽略某些错误。</p><ol><li><p>因此我在上面的测试中还需要验证指定的方法 <code>userRepository).getOne(userId);</code>是否运行过，而且我还使用了参数捕获器，抓取中间的方法参数，用来验证。</p></li><li><p>提供了<code>verify(T mock, VerificationMode mode)</code>方法。<code>VerificationMode</code> 有很多作用，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证指定方法 get(3) 没有被调用  </span></span><br><span class="line">  verify(mock, never()).get(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>verifyZeroInteractions</code>和<code>verifyNoMoreInteractions</code> 验证所有 mock 的方法是否都调用过了。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JUnit 是一个&lt;strong&gt;回归测试框架&lt;/strong&gt;，被开发者用于实施对应用程序的单元测试，加快程序编制速度，同时提高编码的质量。&lt;/p&gt;&lt;p&gt;JUnit 测试框架具有以下重要特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;测试工具&lt;/li&gt;&lt;li&gt;测试套件&lt;/li&gt;&lt;li&gt;测试运行器&lt;/li&gt;&lt;li&gt;测试分类&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十八）Spring Security 权限认证</title>
    <link href="http://blog.wuwii.com/springboot-security.html"/>
    <id>http://blog.wuwii.com/springboot-security.html</id>
    <published>2018-04-22T14:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要实现 <code>Spring Security</code> 的安全认证，结合 <code>RESTful API</code> 的风格，使用无状态的环境。</p><p>主要实现是通过请求的 URL ，通过过滤器来做不同的授权策略操作，为该请求提供某个认证的方法，然后进行认证，授权成功返回授权实例信息，供服务调用。</p><a id="more"></a><p>基于Token的身份验证的过程如下:</p><ol><li>用户通过用户名和密码发送请求。</li><li>程序验证。</li><li>程序返回一个签名的token 给客户端。</li><li>客户端储存token,并且每次用于每次发送请求。</li><li>服务端验证token并返回数据。</li></ol><p>每一次请求都需要token，所以每次请求都会去验证用户身份，所以这里必须要使用缓存，</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="加入相关依赖"><a href="#加入相关依赖" class="headerlink" title="加入相关依赖"></a>加入相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="了解基础配置"><a href="#了解基础配置" class="headerlink" title="了解基础配置"></a>了解基础配置</h4><h5 id="认证的基本信息"><a href="#认证的基本信息" class="headerlink" title="认证的基本信息"></a>认证的基本信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回分配给用户的角色列表</span></span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回密码</span></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回帐号</span></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未过期</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码是否未过期</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否激活</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取基本信息"><a href="#获取基本信息" class="headerlink" title="获取基本信息"></a>获取基本信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据用户名查找用户的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只要实现这个扩展，就能够自定义方式获取认证的基本信息</p><h5 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h5><p><code>WebSecurityConfigurerAdapter</code> 提供了一种便利的方式去创建 <code>WebSecurityConfigurer</code>的实例，只需要重写 <code>WebSecurityConfigurerAdapter</code> 的方法，即可配置拦截什么URL、设置什么权限等安全控制。</p><p>下面是主要会是要到的几个配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要是对身份认证的设置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.disableLocalConfigureAuthenticationBldr = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 复写这个方法来配置 &#123;<span class="doctag">@link</span> HttpSecurity&#125;. </span></span><br><span class="line"><span class="comment">    * 通常，子类不能通过调用 super 来调用此方法，因为它可能会覆盖其配置。 默认配置为：</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       logger.debug(<span class="string">"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."</span>);</span><br><span class="line"></span><br><span class="line">       http</span><br><span class="line">           .authorizeRequests()</span><br><span class="line">               .anyRequest().authenticated()</span><br><span class="line">               .and()</span><br><span class="line">           .formLogin().and()</span><br><span class="line">           .httpBasic();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override this method to configure &#123;<span class="doctag">@link</span> WebSecurity&#125;. For example, if you wish to</span></span><br><span class="line"><span class="comment"> * ignore certain requests.</span></span><br><span class="line"><span class="comment"> * 主要是对某些 web 静态资源的设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p>阅读源码了解。</p><p><img src="https://upload-images.jianshu.io/upload_images/3424642-7418a70abdfc7287.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring Security.jpg"></p><h4 id="AbstractAuthenticationProcessingFilter-doFilter"><a href="#AbstractAuthenticationProcessingFilter-doFilter" class="headerlink" title="AbstractAuthenticationProcessingFilter.doFilter"></a>AbstractAuthenticationProcessingFilter.doFilter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">      HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">      HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"><span class="comment">// 判断是否是需要验证方法（是否是登陆的请求），不是的话直接放过</span></span><br><span class="line">      <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">          chain.doFilter(request, response);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 登陆的请求开始进行验证</span></span><br><span class="line">      Authentication authResult;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 开始认证，attemptAuthentication在 UsernamePasswordAuthenticationFilter 中实现</span></span><br><span class="line">          authResult = attemptAuthentication(request, response);</span><br><span class="line">          <span class="comment">// return null 认证失败</span></span><br><span class="line">          <span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">// 篇幅问题，中间很多代码删了</span></span><br><span class="line">      successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="UsernamePasswordAuthenticationFilter-attemptAuthentication"><a href="#UsernamePasswordAuthenticationFilter-attemptAuthentication" class="headerlink" title="UsernamePasswordAuthenticationFilter.attemptAuthentication"></a>UsernamePasswordAuthenticationFilter.attemptAuthentication</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收并解析用户登陆信息，为已验证的用户返回一个已填充的身份验证令牌，表示成功的身份验证，</span></span><br><span class="line"><span class="comment">// 如果身份验证过程失败，就抛出一个AuthenticationException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 方法将 request 中的 username 和 password 生成 UsernamePasswordAuthenticationToken 对象，用于 AuthenticationManager 的验证</span></span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">username = username.trim();</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line"><span class="comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProviderManager-authenticate"><a href="#ProviderManager-authenticate" class="headerlink" title="ProviderManager.authenticate"></a>ProviderManager.authenticate</h4><p>验证 Authentication 对象（里面包含着验证对象）</p><ol><li>如果有多个 AuthenticationProvider 支持验证传递过来的Authentication 对象，那么由第一个来确定结果，覆盖早期支持AuthenticationProviders 所引发的任何可能的AuthenticationException。 成功验证后，将不会尝试后续的AuthenticationProvider。</li><li>如果最后所有的 AuthenticationProviders 都没有成功验证 Authentication 对象，将抛出 AuthenticationException。</li></ol><p>最后它调用的是 <code>Authentication result = provider.authenticate(authentication);</code></p><p>只要我们自定义 <code>AuthenticationProvider</code> 就能完成自定义认证。</p><h3 id="动手实现安全框架"><a href="#动手实现安全框架" class="headerlink" title="动手实现安全框架"></a>动手实现安全框架</h3><h4 id="使用的依赖"><a href="#使用的依赖" class="headerlink" title="使用的依赖"></a>使用的依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数据表关系"><a href="#数据表关系" class="headerlink" title="数据表关系"></a>数据表关系</h4><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-security/1.png" alt="img"></p><h5 id="User"><a href="#User" class="headerlink" title="User"></a>User</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>, length = <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(targetEntity = UserRole.class, mappedBy = <span class="string">"userId"</span>, fetch = FetchType.EAGER) <span class="comment">// mappedBy 只有在双向关联的时候设置，表示关系维护的一端，否则会生成中间表A_B</span></span><br><span class="line">    <span class="meta">@org</span>.hibernate.annotations.ForeignKey(name = <span class="string">"none"</span>) <span class="comment">// 注意这里不能使用 @JoinColumn 不然会生成外键</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;UserRole&gt; userRoles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UserRole"><a href="#UserRole" class="headerlink" title="UserRole"></a>UserRole</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRole</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">50</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span>(targetEntity = Role.class)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"roleId"</span>, nullable = <span class="keyword">false</span>, foreignKey = <span class="meta">@ForeignKey</span>(name = <span class="string">"none"</span>, value = ConstraintMode.NO_CONSTRAINT))</span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h4><p>认证流程：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-security/3.png" alt="img"></p><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>我使用的是服务端无状态的token 交换的形式，所以引用的是 jwt，首先实现 jwt：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># jwt 配置</span><br><span class="line">jwt:</span><br><span class="line">  # 加密密钥</span><br><span class="line">  secret: 61D73234C4F93E03074D74D74D1E39D9 #blog.wuwii.com</span><br><span class="line">  # token有效时长</span><br><span class="line">  expire: 7 # 7天，单位天</span><br><span class="line">  # token 存在 header 中的参数</span><br><span class="line">  header: token</span><br><span class="line">  </span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jwt"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有效期限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expire;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储 token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        Date nowDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">"typ"</span>, <span class="string">"JWT"</span>)</span><br><span class="line">                <span class="comment">// 后续获取 subject 是 username</span></span><br><span class="line">                .setSubject(username)</span><br><span class="line">                .setIssuedAt(nowDate)</span><br><span class="line">                .setExpiration(DateUtils.addDays(nowDate, expire))</span><br><span class="line">                <span class="comment">// 这里我采用的是 HS512 算法</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析 token，</span></span><br><span class="line"><span class="comment">     * 利用 jjwt 提供的parser传入秘钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据声明 Map&lt;String, Object&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimByToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token是否过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTokenExpired</span><span class="params">(Date expiration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KCException(<span class="string">"无效 token"</span>, HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        Claims claims = getClaimByToken(token);</span><br><span class="line">        <span class="keyword">if</span> (claims == <span class="keyword">null</span> || isTokenExpired(claims.getExpiration())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KCException(header + <span class="string">"失效，请重新登录"</span>, HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims.getSubject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现-UserDetails-和-UserDetailsService"><a href="#实现-UserDetails-和-UserDetailsService" class="headerlink" title="实现 UserDetails 和 UserDetailsService"></a>实现 UserDetails 和 UserDetailsService</h5><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-security/2.png" alt="img"></p><h6 id="实现-UserDetails"><a href="#实现-UserDetails" class="headerlink" title="实现 UserDetails"></a>实现 UserDetails</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsImpl</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetailsImpl</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取权限信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        Set&lt;UserRole&gt; userRoles = user.getUserRoles();</span><br><span class="line">        List&lt;GrantedAuthority&gt; auths = <span class="keyword">new</span> ArrayList&lt;&gt;(userRoles.size());</span><br><span class="line">        userRoles.parallelStream().forEach(userRole -&gt; &#123;</span><br><span class="line">            <span class="comment">// 默认ROLE_  为前缀，可以更改</span></span><br><span class="line">            auths.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_"</span> + userRole.getRole().getName()));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> auths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未过期</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否未锁定</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码是否未过期</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户是否激活</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现-UserDetailsService"><a href="#实现-UserDetailsService" class="headerlink" title="实现 UserDetailsService"></a>实现 UserDetailsService</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"Username is not valid."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"The User is &#123;&#125;"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> SecurityModelFactory.create(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="SecurityModelFactory"><a href="#SecurityModelFactory" class="headerlink" title="SecurityModelFactory"></a>SecurityModelFactory</h6><p>转换 UserDetails 的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityModelFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDetails <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetailsImpl(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="授权认证"><a href="#授权认证" class="headerlink" title="授权认证"></a>授权认证</h5><h6 id="登陆过滤器"><a href="#登陆过滤器" class="headerlink" title="登陆过滤器"></a>登陆过滤器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤，我目前使用的是默认的，可以自己看源码按需求更改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// todo 在这里可以按需求进行过滤，根据源码来修改扩展非常方便</span></span><br><span class="line">        <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要进行登陆认证，会在这里进行预处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// todo 在登陆认证的时候，可以做些其他的验证操作，比如验证码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆成功调用，返回 token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String token = jwtUtil.generateToken(authResult.getName());</span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.getWriter().print(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会进入 <code>doFilter</code> 方法中，这里可以自定义定义过滤；</li><li>然后如果是<code>登陆</code>的请求，会进入 <code>attemptAuthentication</code> 组装登陆信息，并且进行登陆认证；</li><li>如果登陆成功，会调用 <code>successfulAuthentication</code>方法。</li></ol><h6 id="登陆验证"><a href="#登陆验证" class="headerlink" title="登陆验证"></a>登陆验证</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证登录信息,若登陆成功,设置 Authentication</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = authentication.getName();</span><br><span class="line">        String password = (String) authentication.getCredentials();</span><br><span class="line">        UserDetails user = userDetailsService.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (passwordEncoder.matches(password, user.getPassword())) &#123;</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password, authorities);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"The password is not correct."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Provider 是否支持对该类型的凭证提供认证服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UsernamePasswordAuthenticationToken.class.equals(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己定义的 <code>AuthenticationProvider</code> 主要是实现前面经过过滤器封装的认证对象 <code>UsernamePasswordAuthenticationToken</code> 进行解析认证，</p><p>如果认证成功 就给改 <code>UsernamePasswordAuthenticationToken</code> 设置对应的权限,然后返回 <code>Authentication</code></p><ol><li>获得认证的信息；</li><li>去数据库查询信息，获取密码解密验证认证信息；</li><li>认证成功，设置权限信息，返回 <code>Authentication</code>，失败抛出异常。</li></ol><h5 id="JWT-拦截器"><a href="#JWT-拦截器" class="headerlink" title="JWT 拦截器"></a>JWT 拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token 校验</span></span><br><span class="line"><span class="comment"> * BasicAuthenticationFilter 滤器负责处理任何具有HTTP请求头的请求的请求，</span></span><br><span class="line"><span class="comment"> * 以及一个基本的身份验证方案和一个base64编码的用户名:密码令牌。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">BasicAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此方法中检验客户端请求头中的token,</span></span><br><span class="line"><span class="comment">     * 如果存在并合法,就把token中的信息封装到 Authentication 类型的对象中,</span></span><br><span class="line"><span class="comment">     * 最后使用  SecurityContextHolder.getContext().setAuthentication(authentication); 改变或删除当前已经验证的 pricipal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(jwtUtil.getHeader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有token</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过token 获取账户信息，并且存入到将身份信息存放在安全系统的上下文。</span></span><br><span class="line">        UsernamePasswordAuthenticationToken authenticationToken = getAuthentication(token);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析token中的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title">getAuthentication</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String username = jwtUtil.getUsernameFromToken(token);</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>请求进入 <code>doFilterInternal</code> 方法中，对请求是否带<code>token</code>进行判断，</li><li>如果没有token，则直接放行请求；</li><li>如果有 token，则解析它的 post；</li></ol><h5 id="配置权限和相关设置"><a href="#配置权限和相关设置" class="headerlink" title="配置权限和相关设置"></a>配置权限和相关设置</h5><p>自定义配置 Spring Security 配置类 <code>WebSecurityConfig</code>，进项相关配置，并且将所需要的类注入到系统中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// 开启 Security</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>, securedEnabled = <span class="keyword">true</span>, jsr250Enabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">//jsr250Enabled有三种注解，分别是@RolesAllowed,@PermitAll,@DenyAll,功能跟名字一样，</span></span><br><span class="line"><span class="comment">// securedEnabled 开启注解</span></span><br><span class="line"><span class="comment">// prePostEnabled  类似用的最多的是 @PreAuthorize</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtUtil <span class="title">jwtUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtUtil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入 LoginFilter 时候需要，注入 authenticationManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginFilter <span class="title">loginFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LoginFilter loginFilter = <span class="keyword">new</span> LoginFilter();</span><br><span class="line">        loginFilter.setAuthenticationManager(authenticationManager());</span><br><span class="line">        <span class="keyword">return</span> loginFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAuthenticationFilter <span class="title">jwtAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtAuthenticationFilter(authenticationManager());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">customService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetailServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证 AuthenticationProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationProvider <span class="title">authenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomAuthenticationProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BCrypt算法免除存储salt</span></span><br><span class="line"><span class="comment">     * BCrypt算法将salt随机并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt问题。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要是对身份验证的设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        auth</span><br><span class="line">                <span class="comment">// 注入身份的 Bean</span></span><br><span class="line">                .authenticationProvider(authenticationProvider())</span><br><span class="line">                .userDetailsService(userDetailsService())</span><br><span class="line">                <span class="comment">// 默认登陆的加密，自定义登陆的时候无效</span></span><br><span class="line">                .passwordEncoder(passwordEncoder());</span><br><span class="line">        <span class="comment">// 在内存中设置固定的账户密码以及身份信息</span></span><br><span class="line">        <span class="comment">/*auth</span></span><br><span class="line"><span class="comment">                .inMemoryAuthentication().withUser("user").password("password").roles("USER").and()</span></span><br><span class="line"><span class="comment">                .withUser("admin").password("password").roles("USER", "ADMIN");*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">// 关闭 csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 设置 session 状态 STATELESS 无状态</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 需要权限验证</span></span><br><span class="line">                .mvcMatchers(<span class="string">"/user/**"</span>).authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 登陆页面</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                <span class="comment">//.loginPage("/login.html")</span></span><br><span class="line">                <span class="comment">// 登陆成功跳转页面</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/"</span>)</span><br><span class="line">                <span class="comment">//.failureForwardUrl("/login.html")</span></span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 登出</span></span><br><span class="line">                <span class="comment">//.logout()</span></span><br><span class="line">                <span class="comment">// 注销的时候删除会话</span></span><br><span class="line">                <span class="comment">//.deleteCookies("JSESSIONID")</span></span><br><span class="line">                <span class="comment">// 默认登出请求为 /logout，可以用下面自定义</span></span><br><span class="line">                <span class="comment">//.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))</span></span><br><span class="line">                <span class="comment">// 自定义登出成功的页面，默认为登陆页</span></span><br><span class="line">                <span class="comment">//.logoutSuccessUrl("/logout.html")</span></span><br><span class="line">                <span class="comment">//.permitAll()</span></span><br><span class="line">                <span class="comment">//.and()</span></span><br><span class="line">                <span class="comment">// 开启 cookie 保存用户信息</span></span><br><span class="line">                <span class="comment">//.rememberMe()</span></span><br><span class="line">                <span class="comment">// cookie 有效时间</span></span><br><span class="line">                <span class="comment">//.tokenValiditySeconds(60 * 60 * 24 * 7)</span></span><br><span class="line">                <span class="comment">// 设置cookie 的私钥，默认为随机生成的key</span></span><br><span class="line">                <span class="comment">//.key("remember")</span></span><br><span class="line">                <span class="comment">//.and()</span></span><br><span class="line">                <span class="comment">//验证登陆的 filter</span></span><br><span class="line">                .addFilter(loginFilter())</span><br><span class="line">                <span class="comment">//验证token的 filter</span></span><br><span class="line">                .addFilter(jwtAuthenticationFilter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Web层面的配置，一般用来配置无需安全检查的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web</span><br><span class="line">                .ignoring()</span><br><span class="line">                .antMatchers(</span><br><span class="line">                        <span class="string">"**.js"</span>,</span><br><span class="line">                        <span class="string">"**.css"</span>,</span><br><span class="line">                        <span class="string">"/images/**"</span>,</span><br><span class="line">                        <span class="string">"/webjars/**"</span>,</span><br><span class="line">                        <span class="string">"/**/favicon.ico"</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('USER')"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasRole('admin')"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;UserVO&gt;&gt; getAllUser() &#123;</span><br><span class="line">        List&lt;User&gt; users = userService.findAll();</span><br><span class="line">        List&lt;UserVO&gt; userViews = userService.castUserVO(users);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(userViews);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求上面的<code>getAllUser</code> 方法，需要当前用户同时拥有 <code>ROLE_USER</code>和 <code>ROLE_admin</code> 两个权限，才能通过权限验证。</p><p>在 @PreAuthorize 中我们可以利用内建的 SPEL 表达式：比如 ‘hasRole()’ 来决定哪些用户有权访问。需注意的一点是 hasRole 表达式认为每个角色名字前都有一个前缀 ‘ROLE_’。</p><h3 id="迭代上个版本"><a href="#迭代上个版本" class="headerlink" title="迭代上个版本"></a>迭代上个版本</h3><p>后来，我发现进行用户认证的时候，会将所有的 provider 都尝试一遍，那么外面将登陆的 <code>UsernameAndPasswordToken</code> 和 <code>JwtTToken</code> 都可以分别进行验证进行了啊，所有我预先定义 <code>UsernamePasswordAuthenticationToken</code> 包装登陆的信息，然后进入登陆的 <code>AuthenticationProvider</code> 进行认证，<code>token</code> 验证形式，使用 <code>PreAuthenticatedAuthenticationToken</code> 的包装，然后进入例外一个 <code></code>AuthenticationProvider<code></code> 中认证。</p><p>现在我们的流程就更加清晰了。</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-security/4.png" alt="img"></p><p>所以现在我对以前的权限配置以及认证进行了一些更改：</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>在这里，我根据不同请求的类型，进行不同的适配，然后进行加工分装成不同的认证凭证，然后根据凭证的不同，进行不同的认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLoginRequest(httpRequest, httpResponse)) &#123;</span><br><span class="line">                Authentication authResult = processLogin(httpRequest, httpResponse);</span><br><span class="line">                successfulAuthentication(httpRequest, httpResponse, chain, authResult);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String token = obtainToken(httpRequest);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">                processTokenAuthentication(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            unsuccessfulAuthentication(httpRequest, httpResponse, e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆成功调用，返回 token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String token = jwtUtil.generateToken(authResult.getName());</span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.getWriter().print(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLoginRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requiresAuthentication(request, response) &amp;&amp; <span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">obtainToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getHeader(jwtUtil.getHeader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Authentication <span class="title">processLogin</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        String username = obtainUsername(request);</span><br><span class="line">        String password = obtainPassword(request);</span><br><span class="line">        <span class="keyword">return</span> tryAuthenticationWithUsernameAndPassword(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processTokenAuthentication</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Authentication resultOfAuthentication = tryToAuthenticateWithToken(token);</span><br><span class="line">        <span class="comment">// 设置上下文用户信息以及权限</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(resultOfAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Authentication <span class="title">tryAuthenticationWithUsernameAndPassword</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        Authentication authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">        <span class="keyword">return</span> tryToAuthenticate(authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Authentication <span class="title">tryToAuthenticateWithToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        PreAuthenticatedAuthenticationToken requestAuthentication = <span class="keyword">new</span> PreAuthenticatedAuthenticationToken(token, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> tryToAuthenticate(requestAuthentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Authentication <span class="title">tryToAuthenticate</span><span class="params">(Authentication requestAuth)</span> </span>&#123;</span><br><span class="line">        Authentication responseAuth = getAuthenticationManager().authenticate(requestAuth);</span><br><span class="line">        <span class="keyword">if</span> (responseAuth == <span class="keyword">null</span> || !responseAuth.isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(<span class="string">"Unable to authenticate User for provided credentials"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">"User successfully authenticated"</span>);</span><br><span class="line">        <span class="keyword">return</span> responseAuth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="授权认证-1"><a href="#授权认证-1" class="headerlink" title="授权认证"></a>授权认证</h4><p>根据提供的凭证的类型，进行相关的验证操作</p><h5 id="LoginAuthenticationProvider"><a href="#LoginAuthenticationProvider" class="headerlink" title="LoginAuthenticationProvider"></a>LoginAuthenticationProvider</h5><p>跟上个版本的 登陆验证中的 <code>CustomAuthenticationProvider</code> 代码一样实现一样。</p><h5 id="TokenAuthenticateProvider"><a href="#TokenAuthenticateProvider" class="headerlink" title="TokenAuthenticateProvider"></a>TokenAuthenticateProvider</h5><p>根据 token 查找它的 权限 信息，并装在到认证的凭证中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticateProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String token = authentication.getName();</span><br><span class="line">        String username = jwtUtil.getUsernameFromToken(token);</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreAuthenticatedAuthenticationToken(username, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreAuthenticatedAuthenticationToken.class.equals(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置权限和相关设置-1"><a href="#配置权限和相关设置-1" class="headerlink" title="配置权限和相关设置"></a>配置权限和相关设置</h4><p>和上个版本没什么变化，只是将类换了一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// 开启 Security</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>, securedEnabled = <span class="keyword">true</span>, jsr250Enabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtUtil <span class="title">jwtUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtUtil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">customService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetailServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"loginAuthenticationProvider"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationProvider <span class="title">loginAuthenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginAuthenticationProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"tokenAuthenticationProvider"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationProvider <span class="title">tokenAuthenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenAuthenticateProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationFilter <span class="title">authenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AuthenticationFilter authenticationFilter = <span class="keyword">new</span> AuthenticationFilter();</span><br><span class="line">        authenticationFilter.setAuthenticationManager(authenticationManager());</span><br><span class="line">        <span class="keyword">return</span> authenticationFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetailServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要是对身份验证的设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth</span><br><span class="line">                .authenticationProvider(loginAuthenticationProvider())</span><br><span class="line">                .authenticationProvider(tokenAuthenticationProvider())</span><br><span class="line">                .userDetailsService(userDetailsService());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">// 关闭 csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 设置 session 状态 STATELESS 无状态</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 需要权限验证</span></span><br><span class="line">                .mvcMatchers(<span class="string">"/user/**"</span>).authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 登陆页面</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                <span class="comment">//.loginPage("/login.html")</span></span><br><span class="line">                <span class="comment">// 登陆成功跳转页面</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/"</span>)</span><br><span class="line">                .failureForwardUrl(<span class="string">"/login.html"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilter(authenticationFilter())</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后续完善"><a href="#后续完善" class="headerlink" title="后续完善"></a>后续完善</h3><ol><li>修改密码，登出操作 token 的失效机制；</li><li>OAuth2 授权服务器的搭建；</li><li>修改权限后，下次请求刷新权限；</li><li>……</li></ol><h3 id="附录一：HttpSecurity常用方法"><a href="#附录一：HttpSecurity常用方法" class="headerlink" title="附录一：HttpSecurity常用方法"></a>附录一：HttpSecurity常用方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>openidLogin()</code></td><td>用于基于 OpenId 的验证</td></tr><tr><td><code>headers()</code></td><td>将安全标头添加到响应</td></tr><tr><td><code>cors()</code></td><td>配置跨域资源共享（ CORS ）</td></tr><tr><td><code>sessionManagement()</code></td><td>允许配置会话管理</td></tr><tr><td><code>portMapper()</code></td><td>允许配置一个<code>PortMapper</code>(<code>HttpSecurity#(getSharedObject(class))</code>)，其他提供<code>SecurityConfigurer</code>的对象使用 <code>PortMapper</code> 从 HTTP 重定向到 HTTPS 或者从 HTTPS 重定向到 HTTP。默认情况下，Spring Security使用一个<code>PortMapperImpl</code>映射 HTTP 端口8080到 HTTPS 端口8443，HTTP 端口80到 HTTPS 端口443</td></tr><tr><td><code>jee()</code></td><td>配置基于容器的预认证。 在这种情况下，认证由Servlet容器管理</td></tr><tr><td><code>x509()</code></td><td>配置基于x509的认证</td></tr><tr><td><code>rememberMe</code></td><td>允许配置“记住我”的验证</td></tr><tr><td><code>authorizeRequests()</code></td><td>允许基于使用<code>HttpServletRequest</code>限制访问</td></tr><tr><td><code>requestCache()</code></td><td>允许配置请求缓存</td></tr><tr><td><code>exceptionHandling()</code></td><td>允许配置错误处理</td></tr><tr><td><code>securityContext()</code></td><td>在<code>HttpServletRequests</code>之间的<code>SecurityContextHolder</code>上设置<code>SecurityContext</code>的管理。 当使用<code>WebSecurityConfigurerAdapter</code>时，这将自动应用</td></tr><tr><td><code>servletApi()</code></td><td>将<code>HttpServletRequest</code>方法与在其上找到的值集成到<code>SecurityContext</code>中。 当使用<code>WebSecurityConfigurerAdapter</code>时，这将自动应用</td></tr><tr><td><code>csrf()</code></td><td>添加 CSRF 支持，使用<code>WebSecurityConfigurerAdapter</code>时，默认启用</td></tr><tr><td><code>logout()</code></td><td>添加退出登录支持。当使用<code>WebSecurityConfigurerAdapter</code>时，这将自动应用。默认情况是，访问URL”/ logout”，使HTTP Session无效来清除用户，清除已配置的任何<code>#rememberMe()</code>身份验证，清除<code>SecurityContextHolder</code>，然后重定向到”/login?success”</td></tr><tr><td><code>anonymous()</code></td><td>允许配置匿名用户的表示方法。 当与<code>WebSecurityConfigurerAdapter</code>结合使用时，这将自动应用。 默认情况下，匿名用户将使用<code>org.springframework.security.authentication.AnonymousAuthenticationToken</code>表示，并包含角色 “ROLE_ANONYMOUS”</td></tr><tr><td><code>formLogin()</code></td><td>指定支持基于表单的身份验证。如果未指定<code>FormLoginConfigurer#loginPage(String)</code>，则将生成默认登录页面</td></tr><tr><td><code>oauth2Login()</code></td><td>根据外部OAuth 2.0或OpenID Connect 1.0提供程序配置身份验证</td></tr><tr><td><code>requiresChannel()</code></td><td>配置通道安全。为了使该配置有用，必须提供至少一个到所需信道的映射</td></tr><tr><td><code>httpBasic()</code></td><td>配置 Http Basic 验证</td></tr><tr><td><code>addFilterAt()</code></td><td>在指定的Filter类的位置添加过滤器</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要实现 &lt;code&gt;Spring Security&lt;/code&gt; 的安全认证，结合 &lt;code&gt;RESTful API&lt;/code&gt; 的风格，使用无状态的环境。&lt;/p&gt;&lt;p&gt;主要实现是通过请求的 URL ，通过过滤器来做不同的授权策略操作，为该请求提供某个认证的方法，然后进行认证，授权成功返回授权实例信息，供服务调用。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>学习 Docker 笔记</title>
    <link href="http://blog.wuwii.com/docker-note.html"/>
    <id>http://blog.wuwii.com/docker-note.html</id>
    <published>2018-04-13T14:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><p>学习总结来自 Gitbook <a href="https://yeasy.gitbooks.io/docker_practice/content/basic_concept/image.html" rel="external nofollow noopener noreferrer" target="_blank">Docker 从入门到实践的总结</a>；<br>现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。</p><p>这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 <em>shell</em> 脚本基础学习起来时要轻松很多，重点是理解原理，有条件加以实战，才知道原来是这样啊，也能发现发现很多问题。</p><a id="more"></a><h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h3><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><h3 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h3><ol><li>更高效的利用系统资源</li><li>更高效的利用系统资源：直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li><li>一致的运行环境</li><li>持续交付和部署，一次创建或配置，可以在任意地方正常运行。</li><li>更轻松的迁移，可以多平台运行。</li><li>更轻松的维护和扩展，可以自定义镜像。</li></ol><h2 id="了解-Docker-的基本概念"><a href="#了解-Docker-的基本概念" class="headerlink" title="了解 Docker 的基本概念"></a>了解 Docker 的基本概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>Docker 设计时，充分利用 Union FS 的技术，将其设计为分层存储的架构。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像运行时的实体，只是是以镜像为基础层，在其上创建一个当前<strong>容器的存储层</strong>。容器可以被创建、启动、停止、删除、暂停等。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考 <a href="https://blog.wuwii.com/docker-install.html">安装 Docker</a></p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>国内使用加速：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h3><h4 id="查找镜像语法"><a href="#查找镜像语法" class="headerlink" title="查找镜像语法"></a>查找镜像语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>–automated :</strong>只列出 automated build类型的镜像；</p></li><li><p><strong>–no-trunc :</strong>显示完整的镜像描述；</p></li><li><p><strong>-s :</strong>列出收藏数不小于指定值的镜像。</p></li></ul><p>我们首先想使用某个镜像，就可以去 DockerHub 下载，首先去查找镜像，例如我想使用 <code>nginx</code> 镜像并且收藏数大于100：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx -s 100</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                     DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                                    Official build of Nginx.                        8309                [OK]                </span><br><span class="line">jwilder/nginx-proxy                      Automated Nginx reverse proxy <span class="keyword">for</span> docker con…   1312                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm                  Container running Nginx + PHP-FPM capable of…   544                                     [OK]</span><br><span class="line">jrcs/letsencrypt-nginx-proxy-companion   LetsEncrypt container to use with nginx as p…   341                                     [OK]</span><br><span class="line">kong                                     Open-source Microservice &amp; API Management la…   173                 [OK]</span><br></pre></td></tr></table></figure><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>从 Docker 的镜像仓库中拖取镜像 <code>docker pull</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p></p><p>获取 nginx 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx:latest</span><br></pre></td></tr></table></figure><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令，或者 <code>docker images</code>，它会列出所有的镜像。<br>列表包含了 仓库名、标签、镜像 ID（唯一标识）、创建时间 以及 所占用的空间。</p><p>当然命令后面可以接条件，找出符合条件的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li><strong>–digests :</strong>显示镜像的摘要信息；</li><li><strong>-f :</strong>显示满足条件的镜像；</li><li><strong>–format :</strong>指定返回值的模板文件；</li><li><strong>–no-trunc :</strong>显示完整的镜像信息；</li><li><strong>-q :</strong>只显示镜像ID。</li></ul><p>合理的格式获取镜像的参数，可以方便在脚本中的使用。</p><p>查看 nginx 镜像的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls nginx:latest -q</span><br><span class="line">c5c4e8fa2cf7</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><ol><li><p>使用 ID 删除镜像：上面我们查看到 nginx 的 id 很长，但是实际上只要使用前三位以后能够确定到哪个镜像就行了 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm c5c</span><br></pre></td></tr></table></figure></li><li><p>使用镜像名删除镜像：也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm nginx:latest</span><br></pre></td></tr></table></figure></li><li><p>使用镜像摘要删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker image ls nginx --digests</span><br><span class="line">REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353   c5c4e8fa2cf7        6 days ago          109MB</span><br><span class="line"></span><br><span class="line">$ docker image rm nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br><span class="line">Untagged: nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br></pre></td></tr></table></figure></li></ol><p>现在我们就可以使用查询命令来配合使用删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls nginx -q)</span><br><span class="line">Untagged: nginx:latest</span><br><span class="line">Untagged: nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br><span class="line">Deleted: sha256:c5c4e8fa2cf7d87545ed017b60a4b71e047e26c4ebc71eb1709d9e5289f9176f</span><br><span class="line">Deleted: sha256:df08705f06272d44ac0364419532e581af1340fc54ef33423d3735abba422834</span><br><span class="line">Deleted: sha256:220ece772fae32240b2b8491a072c7b30cc0c5c6b67ad73fba6c2968e4ecacd7</span><br></pre></td></tr></table></figure><hr><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>给一个镜像打上指定的标签（它们拥有一样的 IMAGE ID，可以试一试）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag nginx:latest kronchan/nginx:v1.0 </span><br><span class="line">$ docker image ls kronchan/nginx:v1.0        </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">kronchan/nginx      v1.0                c5c4e8fa2cf7        6 days ago          109MB</span><br></pre></td></tr></table></figure><p><strong>但是多个镜像有相同 ID 不能使用 ID 一次性删除：</strong><code>Error response from daemon: conflict: unable to delete c5c4e8fa2cf7 (must be forced) - image is referenced in multiple repositories</code></p><h4 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h4><p><code>Dockerfile</code>是由一系列命令和参数构成的脚本，一个<code>Dockerfile</code>里面包含了构建整个<code>image</code>的完整命令。Docker通过<code>docker build</code>执行<code>Dockerfile</code>中的一系列命令自动构建<code>image</code>。</p><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>所谓定制镜像，那一定是以一个镜像为基础，比如我们需要构建一个 java 项目，就必须要在 java 环境的基础上进行构建，其中基础镜像是必须指定的，<code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:tag]</span><br></pre></td></tr></table></figure><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ol><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，直接追加 shell 命令行；</li><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ol><p>比如给 nginx 制定欢迎页的 <code>Dockerfile</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>在文件所在目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v1.0 .</span><br></pre></td></tr></table></figure><p>注意后面的点不能少，点 <code>.</code> 表示使用当前目录作为上下文环境将文件进行打包，上传到 Docker 引擎服务器，进行构建镜像。</p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>格式：</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" rel="external nofollow noopener noreferrer" target="_blank"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>一般认为拥有和 <code>COPY</code> 一样的功能，但是多了一个自动解压缩的功能。</p><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>容器启动命令，其格式有两种：</p><ol><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，直接追加 shell 命令行；</li><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ol><p>在启动容器的时候，可以使用下面命令覆盖<code>CMD</code> 缺省值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>它指定了当container执行时，需要启动哪些进程。</p><p>两种形式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] （<em>exec</em> 形式, 首选）</li><li>ENTRYPOINT command param1 param2 (<em>shell</em> 形式)</li></ul><p><em>shell</em> 形式防止使用任何<code>CMD</code>或运行命令行参数，但是缺点是您的<code>ENTRYPOINT</code>将作<code>/bin/sh -c</code>的子命令启动，它不传递信号。这意味着可执行文件将不是容器的<code>PID 1</code>，并且不会接收Unix信号，因此您的可执行文件将不会从<code>docker stop &lt;container&gt;</code>接收到<code>SIGTERM</code>。</p><p>只有<code>Dockerfile</code>中最后一个<code>ENTRYPOINT</code>指令会有效果。</p><p><code>docker run &lt;image&gt;</code>的命令行参数将附跟在 <em>exec</em> 形式的<code>ENTRYPOINT</code>中的所有元素之后，并将覆盖使用<code>CMD</code>指定的所有元素。这允许将参数传递到入口点，即<code>docker run &lt;image&gt; -d</code>将把<code>-d</code>参数传递给入口点。</p><p>入口点，和 <code>CMD</code> 一起使用比较好，</p><p>例子：</p><p>编写一个 <code>Dockerfile</code>:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"-c"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像，分别运行两个容器：</p><ol><li><code>$ docker run -d --name test1 test/ubuntu:v1.0</code></li><li><code>$ docker run -d --name test2 test/ubuntu:v1.0 -H</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS                  PORTS                    NAMES</span><br><span class="line">de2ac31d1219        <span class="built_in">test</span>/ubuntu:v1.0              <span class="string">"top -b -H"</span>              2 minutes ago       Up 2 minutes                                     test2</span><br><span class="line">852e5d5119d0        <span class="built_in">test</span>/ubuntu:v1.0              <span class="string">"top -b -c"</span>              3 minutes ago       Up 3 minutes                                     test1</span><br></pre></td></tr></table></figure><p>可以检查容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it test2 ps aux </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.1  36520  1584 ?        Ss   04:04   0:00 top -b -H</span><br><span class="line">root         5  0.0  0.1  34412  1436 pts/0    Rs+  04:15   0:00 ps aux</span><br></pre></td></tr></table></figure><p>启动容器的时候可以使用 <code>--entrypoint=&quot;&quot;: Overwrite the default entrypoint set by the image</code>，覆盖缺省的值。</p><p>TODO ，这方面还需要再了解下。</p><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>设置环境变量，后面可以直接调用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><p><code>-e</code>参数：在启动容器 的时候使用 <code>-e VERSION=2.0</code> 可以覆盖值。</p><p>在容器启动的时候，会缺省创建下面的变量：</p><table><thead><tr><th><strong>Variable</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td><code>HOME</code></td><td>Set based on the value of <code>USER</code></td></tr><tr><td><code>HOSTNAME</code></td><td>The hostname associated with the container</td></tr><tr><td><code>PATH</code></td><td>Includes popular directories, such as :<code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></td></tr><tr><td><code>TERM</code></td><td><code>xterm</code> if the container is allocated a psuedo-TTY</td></tr></tbody></table><h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>构建参数，格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>一般上，容器是不保存任何文件的，因为容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>我们将这些动态数据挂载到主机中，就可以使用挂载卷保存数据。也可以在运行的时候覆盖挂载卷的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit -v mydata:/data image</span><br></pre></td></tr></table></figure><p><code>mydata</code> 为 宿主中的挂载卷，将会挂载到 docker 容器中的 data 这个文件夹中，而且会覆盖 Dockerfile 中设置的匿名挂载卷。</p><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p>这只是一个<strong>声明</strong>，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code>时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>运行时使用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run d -p 8001:8000 IMAGE</span><br></pre></td></tr></table></figure><p>其中 docker 容器的 8000 端口映射到宿主 8000 端口。</p><p>使用 <code>-P</code> 将内部容器所有开放的端口随机分发，你可以使用docker port来查找这个随机绑定端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--expose=[]: Expose a port or a range of ports from the container</span><br><span class="line">            without publishing it to your host</span><br><span class="line">-P=<span class="literal">false</span>   : Publish all exposed ports to the host interfaces</span><br><span class="line">-p=[]      : Publish a container᾿s port to the host (format:</span><br><span class="line">             ip:hostPort:containerPort | ip::containerPort |</span><br><span class="line">             hostPort:containerPort | containerPort)</span><br><span class="line">             (use <span class="string">'docker port'</span> to see the actual mapping)</span><br><span class="line">--link=<span class="string">""</span>  : Add link to another container (name:<span class="built_in">alias</span>)</span><br></pre></td></tr></table></figure><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>区别于 <em>shell</em> 中的 <code>cd</code>的切换命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>由于 Dockerfile 中每个 RUN 都是开启一个容器，所以第二行的命令重启一个容器又是一个新的环境，把那个不知道你切换了文件目录，它还是在原来的位置。如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><p>启动容器的时候可以使用 <code>-w</code>覆盖默认缺省值。</p><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>格式：<code>USER &lt;用户名 or UID&gt;</code></p><p><code>USER</code> 改变后面构建层使用命令的<strong>身份</strong>，这个用户必须是事先建立好的，否则无法切换。</p><p>启动容器的时候可以使用<code>-u</code>覆盖缺省值。</p><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>格式：<code>MAINTAINER [name]</code></p><p><code>MAINTAINER</code>指令允许您设置生成的images的作者字段。</p><h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>// todo</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><code>docker build</code>命令从<code>Dockerfile</code>和<code>context</code>构建image。<code>context</code>是<code>PATH</code>或<code>URL</code>处的文件。<code>PATH</code>本地文件目录。 <code>URL</code>是Git repository的位置。</p><p><code>context</code>以递归方式处理。因此，<code>PATH</code>包括任何子目录，<code>URL</code>包括repository及submodules。一个使用当前目录作为<code>context</code>的简单构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>构建由Docker守护程序运行，而不是由CLI运行。构建过程所做的第一件事是将整个context（递归地）发送给守护进程。大多数情况下，最好是将<code>Dockerfile</code>和所需文件复制到一个空的目录，再到这个目录进行构建。</p><blockquote><p><code>警告</code>：不要使用根目录<code>/</code>作为PATH，因为它会导致构建将硬盘驱动器的所有内容传输到Docker守护程序。</p></blockquote><p>可以使用<code>.dockerignore</code>文件添加到<code>context</code>目录中来排除文件和目录。</p><p>一般的，<code>Dockerfile</code>位于<code>context</code>的根中。但使用<code>-f</code>标志可指定Dockerfile的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>如果build成功，您可以指定要保存新image的repository和tag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure><p>要在构建后将image标记为多个repositories，请在运行构建命令时添加多个<code>-t</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><p>Docker守护程序一个接一个地运行<code>Dockerfile</code>中的指令，如果需要，将每个指令的结果提交到一个新image，最后输出新映像的ID。Docker守护进程将自动清理您发送的context。</p><p>请注意，每个指令独立运行，并导致创建一个新image - 因此<code>RUN cd /tmp</code>对下一个指令不会有任何影响。</p><p>只要有可能，Docker将重新使用中间images（缓存），就是以前构建镜像使用过的指令再次重复使用，加速<code>docker build</code>过程。</p><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p>写一个简单的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my demo</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">MAINTAINER</span> kronchan1@gmail.com</span><br><span class="line"><span class="keyword">ENV</span> MKDIR=new-file \</span><br><span class="line">    FILE=tmpfile</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /kronchan</span></span><br><span class="line"><span class="bash">RUN mkdir <span class="variable">$&#123;MKDIR&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; touch <span class="variable">$&#123;MKDIR&#125;</span>/<span class="variable">$&#123;FILE&#125;</span></span></span><br><span class="line"><span class="bash">COPY file1.tar.gz .</span></span><br><span class="line"><span class="bash">ADD file2.tar .</span></span><br></pre></td></tr></table></figure><p>开始构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile  file1.tar.gz  file2.tar</span><br><span class="line"><span class="comment"># 开始构建镜像</span></span><br><span class="line">$ docker build -t <span class="built_in">test</span>-image .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/7 : FROM busybox</span><br><span class="line"> ---&gt; 8ac48589692a</span><br><span class="line">Step 2/7 : MAINTAINER kronchan1@gmail.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ca58745123bb</span><br><span class="line">Step 3/7 : ENV MKDIR=new-file     FILE=tmpfile</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f6383692900a</span><br><span class="line">Step 4/7 : WORKDIR /kronchan</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f1f4e917cdcf</span><br><span class="line">Step 5/7 : RUN mkdir <span class="variable">$&#123;MKDIR&#125;</span>     &amp;&amp; touch <span class="variable">$&#123;MKDIR&#125;</span>/<span class="variable">$&#123;FILE&#125;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 28963ac16c41</span><br><span class="line">Step 6/7 : COPY file1.tar.gz .</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d4f4affd5b88</span><br><span class="line">Step 7/7 : ADD file2.tar .</span><br><span class="line">^[[A ---&gt; f1ba7424ec6e</span><br><span class="line">Successfully built f1ba7424ec6e</span><br><span class="line">Successfully tagged <span class="built_in">test</span>-image:latest</span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ docker run -it <span class="built_in">test</span>-image</span><br><span class="line"><span class="comment"># 进入容器后，自动进入创建的工作目录</span></span><br><span class="line">/kronchan <span class="comment"># ls</span></span><br><span class="line">file1.tar.gz  file2.tar     new-file</span><br><span class="line"><span class="comment"># 检查环境变量</span></span><br><span class="line">/kronchan <span class="comment"># echo $FILE</span></span><br><span class="line">tmpfile</span><br></pre></td></tr></table></figure><p><strong>突然发现，<code>ADD</code> 指令好像也不能像前面或者网络上前辈们介绍的说自动解压文件，暂时记录，能力有限，也不能说明白，记录下以后不要踩坑，复制文件还是使用 <code>COPY</code> 语义更标准。</strong></p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>语法： <code>docker run</code></p><p>启动 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit nginx</span><br></pre></td></tr></table></figure><p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，</p><p><code>-i</code> 则让容器的标准输入保持打开。</p><p><code>-d</code> 守护状态运行。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>可以利用 <code>docker container start [container ID or NAMES]</code> 命令，直接将一个已经终止的容器启动运行。</p><p>查看<strong>守护状态运行</strong>的容器的输出信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default <span class="string">"all"</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p>可以使用 <code>docker container stop [container ID or NAMES]</code> 来终止一个运行中的容器。</p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><code>exec</code> 命令</p><p>一般使用 <code>-i</code>，<code>-t</code>参数后就可以有终端和提示符。</p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><ol><li>可以使用 <code>docker container rm [container ID or NAMES]</code> 来删除一个处于终止状态的容器。</li><li>如果需要删除运行状态中的容器，加上参数 <code>-f</code> 强制删除；</li><li><code>$ docker container prune</code> 清理所有处于终止状态的容器。</li></ol><h4 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h4><ol><li><p>导出容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> 180f &gt; /root/springboot-docker.tar</span><br></pre></td></tr></table></figure></li><li><p>导入容器快照：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import - kronchan/springboot-docker:v1.0</span><br></pre></td></tr></table></figure><p>还可以导入 url 中的文件作为镜像。</p></li></ol><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>，但是国内推送的速度在没有翻墙的情况下比较尴尬，所以可以使用 <a href="https://cr.console.aliyun.com/?spm=a2c4e.11153959.blogcont29941.9.520269d65b5sBo&amp;accounttraceid=7944ca1b-ff8f-4239-91ba-79d103b8e92e#/imageList" rel="external nofollow noopener noreferrer" target="_blank">阿里云镜像服务</a>。</p><ol><li><p>登陆 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><p>然后输入账号密码。</p></li><li><p>标记 TAG（可选）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [ImageId] com.wuwii/&lt;image&gt;[:镜像版本号]</span><br></pre></td></tr></table></figure></li><li><p>推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push [image]</span><br></pre></td></tr></table></figure></li></ol><h4 id="提交构建文件到仓库"><a href="#提交构建文件到仓库" class="headerlink" title="提交构建文件到仓库"></a>提交构建文件到仓库</h4><p>只需要将构建镜像的 <code>Dockerfile</code> 和其余相关的文件一同 <code>push</code> 到代码托管仓库，再次 <code>push</code> 下来就能重新构建镜像。</p><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><p><strong>Command：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume </span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volume</span><br><span class="line">  prune       Remove all unused volumes </span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><h4 id="容器挂载数据卷"><a href="#容器挂载数据卷" class="headerlink" title="容器挂载数据卷"></a>容器挂载数据卷</h4><p>例如我启动一个 <code>jenkins</code> 容器，命名为 <code>my_jenkins</code>，将容器的 <code>var/jenkins_home/</code>目录挂载到数据卷 <code>my_jenkins</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my_jenkins_volume</span><br><span class="line"></span><br><span class="line">$ docker run -p 7322:8080 -p 50000:50000 -v my_jenkins_volume:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure><blockquote><p><code>-v my_jenkins_volume:/var/jenkins_home/</code> 可以理解是 <code>--mount source=my_jenkins_volume,target=/var/jenkins_home/</code>，后面一种更好理解，也是推荐使用的。</p></blockquote><p>查询容器信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect my_jenkins</span><br><span class="line"></span><br><span class="line">…………</span><br><span class="line"> <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"my_jenkins_volume"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my_jenkins_volume/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/var/jenkins_home"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">"z"</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><h4 id="挂载主机文件作为数据卷"><a href="#挂载主机文件作为数据卷" class="headerlink" title="挂载主机文件作为数据卷"></a>挂载主机文件作为数据卷</h4><p>不光可以将数据卷挂载到容器中，我们还可以直接将宿主的文件直接作为数据卷使用，完成一样的效果。</p><p>上面的，我将宿主的文件夹 <code>/var/my_jenkins</code>，作为数据卷挂载到 <code>/var/my_jenkins</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 7322:8080 -p 50000:50000 -v /var/jenkins_home/:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure><blockquote><p>也可以用 <code>--mount type=bind,source=/var/jenkins_home/,target=/var/jenkins_home/</code></p></blockquote><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/docker/network.png" alt="image"></p><h4 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h4><p>使用<code>-p</code>和<code>-P</code> 设置主机和容器的映射端口。</p><h4 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h4><p><strong>使用自定义网络 （network）进行互联。</strong></p><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">"sh"</span>                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">"sh"</span>                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>在自定义配置文件中加入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后每次启动容器都会自动配置上面的 <code>DNS</code>。</p><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h4 id="容器访问外网"><a href="#容器访问外网" class="headerlink" title="容器访问外网"></a>容器访问外网</h4><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>如果为 0，说明没有开启转发，则需要手动打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker镜像在创建之后，往往需要自己手动pull来获取镜像，然后执行run命令来运行。当服务需要用到多种容器，容器之间又产生了各种依赖和连接的时候，部署一个服务的手动操作是令人感到十分厌烦的。</p><p>Dcoker-Compose技术，就是通过一个<code>.yml</code>配置文件，将所有的容器的部署方法、文件映射、容器连接等等一系列的配置写在一个配置文件里，最后只需要执行<code>docker-compose up</code>命令就会像执行脚本一样的去一个个安装容器并自动部署他们，极大的便利了复杂服务的部署。</p><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p><p>首先介绍几个术语。</p><ul><li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Linux 上默认是没有安装 <code>docker-compose</code>，查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version    </span><br><span class="line">-bash: /usr/bin/docker-compose: No such file or directory</span><br></pre></td></tr></table></figure><p>没有安装。</p><p>从 <a href="https://github.com/docker/compose/releases" rel="external nofollow noopener noreferrer" target="_blank">官方 GitHub Release</a> 处直接下载编译好的二进制文件，</p><p>使用二进制包安装，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="模板指令"><a href="#模板指令" class="headerlink" title="模板指令"></a>模板指令</h3><p>使用的 <code>version: 3</code></p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><blockquote><p><code>注意</code>：YAML布尔值（true，false，yes，no，on，off）必须用引号引起来，以便解析器将其解释为字符串。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./dir</span> <span class="comment"># Dockerfile所在目录， 或者远程仓库的地址</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile-alternate</span> <span class="comment"># 指定 Dockerfile</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="attr">        buildno:</span> <span class="number">1</span> <span class="comment"># 只有在构建时候能使用的变量</span></span><br><span class="line"><span class="attr">      cache_from:</span> <span class="comment"># 设置镜像构建名</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">alpine:latest</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><p>build 不能和 image 一起去使用</p><h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h4><p>指定容器的内核能力（capacity）分配。</p><ol><li><p>让容器拥有所有能力：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure></li><li><p>让容器移除某些能力：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">NET_ADMIN</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SYS_ADMIN</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令。</p><h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>为容器指定可选的父cgroup。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">m-executor-abcd</span></span><br></pre></td></tr></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定自定义容器名称，而不是生成的默认名称。</p><blockquote><p>由于Docker容器名称必须是唯一的，因此如果您指定了自定义名称，则无法将服务扩展到1个容器之外。 尝试这样做会导致错误。</p></blockquote><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>Express之间的依赖关系，有两个效果：</p><ul><li><p><code>docker-compose up</code> 将按照依赖顺序启动服务。 在下面的示例中，db和redis将在web之前启动。</p></li><li><p><code>docker-compose up SERVICE</code> 将自动包含SERVICE的依赖关系。 在以下示例中，docker-compose up web也将创建并启动db和redis。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p><code>注意</code>：在启动web之前，depends_on不会等待db和redis“就绪”，直到它们被启动。 如果您需要等待服务准备就绪，请参阅控制<a href="https://docs.docker.com/compose/startup-order/" rel="external nofollow noopener noreferrer" target="_blank">启动顺序</a>了解有关此问题的更多信息以及解决问题的策略。</p></blockquote></li></ul><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义DNS服务器。可以是单个值或列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain1.example.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>挂载一个或者多个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/run</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件添加环境变量。可以是单个值或列表。</p><p>如果已使用<code>docker-compose -f FILE</code>指定了一个Compose文件，则<code>env_file</code>中的路径相对于该文件所在的目录。</p><p>在环境中指定的环境变量会覆盖这些值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env_file:</span> <span class="string">.env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env_file:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">./common.env</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">./apps/web.env</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/opt/secrets.env</span></span><br></pre></td></tr></table></figure><p>Compose期望env文件中的每一行都处于<code>VAR = VAL</code>格式。 以＃开头的行（即注释）将被忽略，空行也是如此。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set Rails/Rack environment</span></span><br><span class="line"><span class="string">RACK_ENV=development</span></span><br></pre></td></tr></table></figure><blockquote><p><code>注意</code>：如果您的service指定了build选项，则在build过程中将不会自动显示环境文件中定义的变量。 使用build的args子选项来定义构建时环境变量。</p></blockquote><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">  RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">  SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数，</p><p>这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加主机名的标签，就是往 <code>/etc/hosts</code>文件中添加一些记录，与 <code>Docker client</code> 的 <code>--add-host</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加相应 host。</p><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  interval:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="attr">ubuntu:latest</span></span><br></pre></td></tr></table></figure><h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="string">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="string">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>这个标签解决的是容器连接问题，与<code>Docker client</code>的 <code>--link</code>一样效果，会连接到其它服务中的容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">db</span></span><br><span class="line"><span class="attr"> - db:</span><span class="string">database</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>使用的别名将会自动在服务容器中的/etc/hosts里创建。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.12.2.186  db</span><br><span class="line">172.12.2.186  database</span><br><span class="line">172.12.2.187  redis</span><br></pre></td></tr></table></figure><p>相应的环境变量也将被创建。</p><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  driver:</span> <span class="string">syslog</span></span><br><span class="line"><span class="attr">  options:</span></span><br><span class="line"><span class="attr">    syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line"><span class="attr">  max-size:</span> <span class="string">"200k"</span></span><br><span class="line"><span class="attr">  max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span> <span class="comment"># 桥接模式，这种模式下， docker 会默认创建一个 docker0 的网桥，从它中分配 ip 提供给容器使用</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span> <span class="comment"># 使用主机网络</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span> <span class="comment"># 只能访问本地网络，不能使用外网</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span> <span class="comment"># 与其他某个 service 共享一个网络</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span> <span class="comment"># 与其他某个容器共享一个网络</span></span><br></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  some-service:</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">some-network</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  some-network:</span></span><br><span class="line"><span class="attr">  other-network:</span></span><br></pre></td></tr></table></figure><h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h4><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure><p><em>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>Docker命令行工具提供了<code>docker secret</code>命令来管理敏感信息，</p><p>从 Docker Compose V3.1开始，支持在容器编排文件中使用 secret，这可以方便地在不同容器中分享所需的敏感信息。</p><p><strong><code>docker secret</code> 只能从<code>Docker Swarm</code>模式的<code>manager</code>节点调用，如果你在本机进行试验，请先执行 <code>docker swarm init</code>命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker secret --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:    docker secret COMMAND</span><br><span class="line"></span><br><span class="line">Manage Docker secrets</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a secret from a file or STDIN as content</span><br><span class="line">  inspect     Display detailed information on one or more secrets</span><br><span class="line">  ls          List secrets</span><br><span class="line">  rm          Remove one or more secrets</span><br></pre></td></tr></table></figure><p>创建一个数据库密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"kronchan"</span> |  docker secret create db_password -</span><br><span class="line">yxadqo4xguucuyhd9oxc5t4q2</span><br><span class="line">$ docker secret ls</span><br><span class="line">ID                          NAME                DRIVER              CREATED             UPDATED</span><br><span class="line">yxadqo4xguucuyhd9oxc5t4q2   db_password                             3 seconds ago       3 seconds ago</span><br></pre></td></tr></table></figure><p>在服务编排中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_password</span> <span class="comment"># 缺省值</span></span><br><span class="line"><span class="attr">  secrets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">db_password</span></span><br></pre></td></tr></table></figure><p>在 Swarm 集群中 ，例如，我用这个密码启动一个 MYSQL 服务，在 manage 节点中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">        --name mysql \</span><br><span class="line">        --secret <span class="built_in">source</span>=db_password,target=mysql_root_password \</span><br><span class="line">        -e MYSQL_ROOT_PASSWORD_FILE=<span class="string">"/run/secrets/mysql_root_password"</span> \</span><br><span class="line">        mysql:latest</span><br></pre></td></tr></table></figure><p>这个过程分为两个步骤：</p><ol><li><code>source</code> 指定容器使用 secret 后，secret 会被解密并存放到<strong>容器的文件系统</strong>中，默认位置为 <code>/run/secrets/&lt;secret_name&gt;</code>，可以使用 <code>target</code> 重新定位。</li><li>设置环境变量 <code>MYSQL_ROOT_PASSWORD_FILE</code> 指定从 <code>/run/secrets/mysql_root_password</code> 中读取并设置 MySQL 的管理员密码。</li></ol><h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">user:USER</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">role:ROLE</span></span><br></pre></td></tr></table></figure><h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置另一个信号来停止容器。在默认情况下使用的是 <code>SIGTERM</code> 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span> <span class="comment"># 缺省值</span></span><br></pre></td></tr></table></figure><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="string">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="string">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># other grammar</span></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><h4 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h4><p>指定容器的 <code>ulimits</code> 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line"><span class="attr">  nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">  nofile:</span></span><br><span class="line"><span class="attr">    soft:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">    hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="comment"># 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># 使用绝对路径挂载数据卷</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/opt/data:/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="comment"># 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br><span class="line"> <span class="comment"># 已经存在的命名的数据卷。</span></span><br><span class="line"><span class="attr"> - datavolume:</span><span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>例如编排一个 pqsql:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line"><span class="attr">  pq:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:9.5</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - db_data:</span><span class="string">/var/lib/postgresql</span></span><br><span class="line"><span class="attr">      - db_log:</span><span class="string">/var/log/postgresql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db_data:</span></span><br><span class="line"><span class="attr">  db_log:</span></span><br></pre></td></tr></table></figure><p>举个例子，自动创建一个数据卷 <code>pq_db_data</code>，目录在 <code>/var/lib/docker/volumes/</code> 下。</p><p>将 容器 <code>pq</code> 的目录 <code>/var/lib/postgresql</code> 挂载到数据卷 <code>pq_db_data</code>。</p><h4 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes_from"></a>volumes_from</h4><p>从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes_from:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">service_name</span></span><br><span class="line"><span class="attr">  - service_name:</span><span class="string">ro</span></span><br><span class="line"><span class="attr">  - container:</span><span class="string">container_name</span></span><br><span class="line"><span class="attr">  - container:</span><span class="attr">container_name:rw</span></span><br></pre></td></tr></table></figure><h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><h4 id="privileged"><a href="#privileged" class="headerlink" title="privileged"></a>privileged</h4><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Swarm 中失效，Swarm Stacks use the <code>restart_policy:</code> under the <code>deploy:</code></p></blockquote><h4 id="working-dir"><a href="#working-dir" class="headerlink" title="working_dir"></a>working_dir</h4><p>指定容器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">working_dir</span></span><br></pre></td></tr></table></figure><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="基本的使用格式"><a href="#基本的使用格式" class="headerlink" title="基本的使用格式"></a>基本的使用格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><p><code>options</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f, --file FILE           指定启动模版文件(一个非docker-compose.yml命名的yaml文件,默认为docker-compose.yml)</span><br><span class="line">-p, --project-name NAME   指定一个替代项目名称 (默认是directory名)</span><br><span class="line">-d 以daemon的方式启动容器</span><br><span class="line">--x-networking            (EXPERIMENTAL) 使用新的网络功能</span><br><span class="line">--x-network-driver DRIVER (EXPERIMENTAL) 指定网络驱动程序，桥 (default: <span class="string">"bridge"</span>).</span><br><span class="line">--verbose：输出详细信息</span><br><span class="line">--version 打印版本并退出。</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h5><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h5 id="down"><a href="#down" class="headerlink" title="down"></a>down</h5><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络。</p><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>进入指定的容器。</p><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><p>获取命令的帮助信息。</p><h5 id="images"><a href="#images" class="headerlink" title="images"></a>images</h5><p>列出这个 Compose 项目中包含的镜像。</p><h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h5 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h5><p>暂停一个或多个容器。</p><h5 id="port"><a href="#port" class="headerlink" title="port"></a>port</h5><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h5 id="restart-1"><a href="#restart-1" class="headerlink" title="restart"></a>restart</h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h5 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h5><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>查看各个服务容器内运行的进程。</p><h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h5 id="up"><a href="#up" class="headerlink" title="up"></a>up</h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>实战 <code>WordPress</code> 项目：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   db:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="attr">       - db_data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   wordpress:</span></span><br><span class="line"><span class="attr">     depends_on:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">wordpress:latest</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"8000:80"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    db_data:</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>docker技术是基于Linux内核的<code>cgroup</code>技术实现的，那么问题来了，在非Linux平台上是否就不能使用docker技术了呢？答案是可以的，不过显然需要借助虚拟机去模拟出Linux环境来。</p><p>Docker Machine 就是docker公司官方提出的，用于在各种平台上快速创建具有docker服务的虚拟机的技术，甚至可以通过指定driver来定制虚拟机的实现原理（一般是virtualbox）。</p><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>查询版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br></pre></td></tr></table></figure><p>在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><p>完成后，查看版本信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br><span class="line">docker-machine version 0.13.0, build 9ba6da9</span><br></pre></td></tr></table></figure><h3 id="创建本地主机驱动"><a href="#创建本地主机驱动" class="headerlink" title="创建本地主机驱动"></a>创建本地主机驱动</h3><ol><li><p>创建一个 <code>virtualbox</code> 类型的驱动，名为 <code>test1</code>，可以加上参数配置分配的硬件的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox test1</span><br><span class="line">Running pre-create checks...</span><br><span class="line">Error with pre-create check: <span class="string">"VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path"</span></span><br></pre></td></tr></table></figure><p>出现了错误，需要安装VirtualBox环境</p><ul><li><p>配置VirtualBox源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$  vim /etc/yum.repos.d/virtualbox.repo    </span><br><span class="line">[virtualbox]</span><br><span class="line">name=Oracle Linux / RHEL / CentOS-<span class="variable">$releasever</span> / <span class="variable">$basearch</span> - VirtualBox</span><br><span class="line">baseurl=http://download.virtualbox.org/virtualbox/rpm/el/<span class="variable">$releasever</span>/<span class="variable">$basearch</span></span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://www.virtualbox.org/download/oracle_vbox.asc</span><br></pre></td></tr></table></figure></li><li><p>安装VirtualBox</p><ul><li><p>CentOS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先搜索</span></span><br><span class="line"><span class="comment"># 2. 安装版本</span></span><br><span class="line"><span class="comment"># 3. 重新加载配置</span></span><br><span class="line">$ yum search VirtualBox </span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">======================================= N/S matched: VirtualBox ========================================</span><br><span class="line">VirtualBox-4.3.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.0.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.1.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.2.x86_64 : Oracle VM VirtualBox</span><br><span class="line"></span><br><span class="line">  Name and summary matches only, use <span class="string">"search all"</span> <span class="keyword">for</span> everything.</span><br><span class="line">$ yum install -y VirtualBox-5.1</span><br><span class="line">$ /sbin/vboxconfig    </span><br><span class="line"><span class="comment"># 中间出了点问题，说是少了</span></span><br><span class="line"><span class="comment"># This system is not currently set up to build kernel modules (system extensions).</span></span><br><span class="line"><span class="comment">#Running the following commands should set the system up correctly:</span></span><br><span class="line"><span class="comment">#   yum install kernel-devel-3.10.0-693.2.2.el7.x86_64</span></span><br><span class="line">$ yum install kernel-devel-3.10.0-693.2.2.el7.x86_64</span><br><span class="line"><span class="comment"># 重新再次加载</span></span><br><span class="line">$ /sbin/vboxconfig  </span><br><span class="line"><span class="comment"># 启动成功，心累</span></span><br></pre></td></tr></table></figure><p>然后就可以创建了虚拟驱动了。</p></li><li><p>Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手上暂时没有 Ubuntu 系统没有测试，网上都是这么说的，记录下，没有验证，</span></span><br><span class="line">$ apt-get install virtualbox</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>还有一种问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory"</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/docker/machine/issues/4271" rel="external nofollow noopener noreferrer" target="_blank">issues/4271</a>额，我之前是一直远程在阿里云上的服务器做的， 由于一直很讨厌 WINDOW 的命令模式，甩锅啦，现在好了，这个问题要修改 BIOS ，只好又回到 WINDOW 平台上做</p></li><li><p>登陆到主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls </span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">default   *        virtualbox   Running   tcp://192.168.99.100:2376           v17.12.0-ce</span><br><span class="line">test1     -        virtualbox   Running   tcp://192.168.99.101:2376           v18.04.0-ce</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh test1</span><br><span class="line"><span class="comment"># 后面就可以操作 test1 了</span></span><br></pre></td></tr></table></figure></li></ol><p>补充，通过 <code>-d</code> 选项可以选择支持的驱动类型。</p><ul><li>amazonec2</li><li>azure</li><li>digitalocean</li><li>exoscale</li><li>generic</li><li>google</li><li>hyperv</li><li>none</li><li>openstack</li><li>rackspace</li><li>softlayer</li><li>virtualbox</li><li>vmwarevcloudair</li><li>vmwarefusion</li><li>vmwarevsphere</li></ul><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><ul><li><code>active</code> 查看活跃的 Docker 主机</li><li><code>config</code> 输出连接的配置信息</li><li><code>create</code> 创建一个 Docker 主机</li><li><code>env</code> 显示连接到某个主机需要的环境变量</li><li><code>inspect</code> 输出主机更多信息</li><li><code>ip</code> 获取主机地址</li><li><code>kill</code> 停止某个主机</li><li><code>ls</code> 列出所有管理的主机</li><li><code>provision</code> 重新设置一个已存在的主机</li><li><code>regenerate-certs</code> 为某个主机重新生成 TLS 认证信息</li><li><code>restart</code> 重启主机</li><li><code>rm</code> 删除某台主机</li><li><code>ssh</code> SSH 到主机上执行命令</li><li><code>scp</code> 在主机之间复制文件</li><li><code>mount</code> 挂载主机目录到本地</li><li><code>start</code> 启动一个主机</li><li><code>status</code> 查看主机状态</li><li><code>stop</code> 停止一个主机</li><li><code>upgrade</code> 更新主机 Docker 版本为最新</li><li><code>url</code> 获取主机的 URL</li><li><code>version</code> 输出 docker-machine 版本信息</li><li><code>help</code> 输出帮助信息</li></ul><h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p>Docker 1.12 <a href="https://docs.docker.com/engine/swarm/" rel="external nofollow noopener noreferrer" target="_blank">Swarm mode</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>。</p><p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。</p><p>节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点。</p><p>管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p><p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p><p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" alt="img"></p><h4 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h4><p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。</p><p>服务 （<code>Services</code>） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</li><li><code>global services</code> 每个工作节点上运行一个任务</li></ul><p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p><p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p><p><img src="https://docs.docker.com/engine/swarm/images/services-diagram.png" alt="img"></p><h3 id="创建-Swarm-集群"><a href="#创建-Swarm-集群" class="headerlink" title="创建 Swarm 集群"></a>创建 Swarm 集群</h3><p>前面我们了解到 Swarm 集群是由 <code>manager</code> 和 <code>worker</code> 组成的。</p><h4 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h4><p>初始化一个 manager，主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code> 指定 IP。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager</span><br><span class="line"></span><br><span class="line">docker@manager:~$ docker-machine ssh manager</span><br><span class="line">docker@manager:~$ ip addr</span><br><span class="line"><span class="comment"># 主机有多个网卡，拥有多个 IP，必须使用 --advertise-addr 指定 IP。</span></span><br><span class="line">docker@manager:~$ docker swarm init --advertise-addr 192.168.99.102</span><br><span class="line">Swarm initialized: current node (wwyq0ym88dvuhxkljr4963kei) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-3js3ppvjj191r9qx92uiva4l64z8xgy6sno69et5y9ri7a8es5-695418k4uks90r9j9bgwag2k3 192.168.99.102:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br></pre></td></tr></table></figure><h4 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h4><ol><li><p>新增加一个工作节点 <code>worker1</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox worker1</span><br><span class="line">$ docker-machine ssh worker1</span><br><span class="line"></span><br><span class="line">docker@worker1:~$ docker swarm join --token SWMTKN-1-3js3ppvjj191r9qx92uiva4l64z8xgy6sno69et5y9ri7a8es5-695418k4uks90r9j</span><br><span class="line">9bgwag2k3 192.168.99.102:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li><li><p>然后按照上面的步骤，新增一个节点 <code>worker2</code>。</p></li><li><p>进入 <code>manager</code> 节点 ，查看集群状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker@manager:~$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">wwyq0ym88dvuhxkljr4963kei *   manager             Ready               Active              Leader              18.04.0-ce</span><br><span class="line">dncrx0o8lbq0a5v8lcdwt2onl     worker1             Ready               Active                                  18.04.0-ce</span><br><span class="line">d9d9pjhwh86lz42klh41ud8ss     worker2             Ready               Active</span><br></pre></td></tr></table></figure></li></ol><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>我们使用 <code>docker service</code> 命令来管理 <code>Swarm</code> 集群中的服务，该命令只能在管理（manager）节点运行。</p><h4 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h4><p>在上面我们创建的 Swarm 集群中的 <code>manager</code> 节点中 运行一个 nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</span><br><span class="line">mqisdpsereiv0x3whj74lpbxi</span><br><span class="line">overall progress: 3 out of 3 tasks</span><br><span class="line">1/3: running   [==================================================&gt;]</span><br><span class="line">2/3: running   [==================================================&gt;]</span><br><span class="line">3/3: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><h4 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询服务</span></span><br><span class="line">docker@manager:~$ docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                 PORTS</span><br><span class="line">mqisdpsereiv        nginx               replicated          3/3                 nginx:1.13.7-alpine   *:80-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询进程</span></span><br><span class="line">docker@manager:~$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                 NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS</span><br><span class="line">wyvxj6nyp435        nginx.1             nginx:1.13.7-alpine   manager             Running             Running 2 minutes ago</span><br><span class="line">o9qb0pmi1epu        nginx.2             nginx:1.13.7-alpine   worker1             Running             Running 3 minutes ago</span><br><span class="line">45uxv7c6s2b0        nginx.3             nginx:1.13.7-alpine   worker2             Running             Running 3 minutes ago</span><br></pre></td></tr></table></figure><p>我的集群三个节点的 IP 分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">manager   -        virtualbox   Running   tcp://192.168.99.102:2376           v18.04.0-ce</span><br><span class="line">worker1   -        virtualbox   Running   tcp://192.168.99.103:2376           v18.04.0-ce</span><br><span class="line">worker2   -        virtualbox   Running   tcp://192.168.99.104:2376           v18.04.0-ce</span><br></pre></td></tr></table></figure><p>分别访问这几个节点的 ip 都能访问到熟悉 nginx 欢迎页。</p><p>查询日志 <code>docker service logs &lt;service&gt;</code></p><h4 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h4><p>使用 <code>docker service rm</code> 来从 <code>Swarm</code> 集群移除某个服务。</p><h3 id="使用-compose-文件部署"><a href="#使用-compose-文件部署" class="headerlink" title="使用 compose 文件部署"></a>使用 compose 文件部署</h3><p><strong>需要注意的 swarm 的compose 多出一些模板指令，而且以前 <code>docker-compose</code> 中的一些指令将失效。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部署服务使用 <code>docker stack deploy</code>，其中 <code>-c</code> 参数指定 compose 文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose-swarm.yml myweb-name</span><br></pre></td></tr></table></figure><p>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ls</span><br><span class="line">NAME                SERVICES</span><br><span class="line">wordpress           2</span><br></pre></td></tr></table></figure><p>移除服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack down</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/learning-code/tree/master/springboot-docker?1523630460079" rel="external nofollow noopener noreferrer" target="_blank">服务编排和 Swarm集群的例子</a></p><p>我们以在 <code>Swarm</code> 集群中部署 <code>WordPress</code> 为例进行说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  wordpress:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">overlay</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      mode:</span> <span class="string">replicated</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">overlay</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - db-data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  visualizer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="attr">    stop_grace_period:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  overlay:</span></span><br></pre></td></tr></table></figure><p>在 <code>Swarm</code> 集群管理节点新建该文件，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p><h2 id="远程-API-架构"><a href="#远程-API-架构" class="headerlink" title="远程 API 架构"></a>远程 API 架构</h2><h3 id="了解-1"><a href="#了解-1" class="headerlink" title="了解"></a>了解</h3><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p>Docker的基础服务，比如容器的创建、查看、停止、镜像的管理，其实都是由docker的守护进程(daemon)来实现的。</p><p>每次执行的Docker指令其实都是通过向daemon发送请求来实现的。</p><p>daemon的运作（通信模式）主要有两种，一种是通过unix套接字（默认，但只能在本地访问到，比较安全），一种是通过监听tcp协议地址和端口来实现（这个可以实现在远程调用到docker服务）。</p><h4 id="远程-API"><a href="#远程-API" class="headerlink" title="远程 API"></a>远程 API</h4><p>除了通过远程tcp协议访问远程主机上的docker服务外，docker还提供了一套基于HTTP的API，可以使用curl来实现操作远程主机上的docker服务，这为开发基于WEB的docker服务提供了便利。</p><h3 id="开启远程-API"><a href="#开启远程-API" class="headerlink" title="开启远程 API"></a>开启远程 API</h3><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>1.12版本后, 用户可以自行创建配置文件 <code>/etc/docker/daemon.json</code>，该文件不区分系统，是通用的，推荐使用。具体参考：<a href="https://docs.docker.com/engine/admin/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>。不知道版本的可以通过 <code>$ dockerd version</code> 查看。</p><p>方式一： 首先，你需要创建 <code>/etc/docker/daemon.json</code> 文件，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hosts"</span>: [</span><br><span class="line">    <span class="string">"tcp://0.0.0.0:2375"</span>,</span><br><span class="line">    <span class="string">"unix:///var/run/docker.sock"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启的是 <code>2375</code> 端口。</p><p>然后重启生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>方式二 ： 当然也可以更改启动命令的方式 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 系统</span></span><br><span class="line">$ sudo vim /lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改下面的启动命令</span></span><br><span class="line">ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>使用的时候只需要在客户端的主机上加上环境变量 <code>DOCKER_HOST=tcp://xxx.xxx.xx.xx/2375</code>，就可以在主机上使用远程的 Docker API。</p><h4 id="Docker-Toolbox"><a href="#Docker-Toolbox" class="headerlink" title="Docker Toolbox"></a>Docker Toolbox</h4><ol><li><p>在 window 或者 mac 上面使用 <code>Docker-toolbox</code>，则就比较简单了，,打开 <code>docker QuickStart Terminal</code> 终端，输入命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">default   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.10.0-ce</span><br></pre></td></tr></table></figure><p>查询到 URL，根据上面的结果</p><p>我使用的是 WONDOW 电脑的主机上加上环境变量 <code>DOCKER_HOST=tcp://192.168.99.100:2376</code>；</p><p>当然也可以使用 <code>VirtualBox</code> 的端口映射到 本地的 2375端口也行，docker 默认的 host 是 <code>127.0.0.1:2376</code>，这样环境变量也不用配置。</p></li><li><p>我使用的是 WIN10 ，后面也是这个开发环境，打开 <code>PowerShell</code> 执行命令 docker version 命令发现一个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get http://192.168.99.100:2376/v1.33/containers/json: malformed HTTP response <span class="string">"\x15\x03\x01\x00\x02\x02"</span>.</span><br><span class="line">* Are you trying to connect to a TLS-enabled daemon without TLS?</span><br></pre></td></tr></table></figure><p>发现它需要 TLS ，</p><p>设置环境变量 <code>DOCKER_TLS_VERIFY=1</code></p></li><li><p>然后再次执行 docker version 命令，发现又出现 问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The server probably has client authentication (--tlsverify) enabled. Please check your TLS client certification settings: Get https://192.168.99.100:2376/v1.35/version: remote error: tls: bad certificate</span><br></pre></td></tr></table></figure><p>没指定 证书 <code>cret</code>。 证书的路径在当前用户的 <code>/.docker/certs</code>下：</p><p>设置环境变量 <code>DOCKER_CERT_PATH=C:/Users/KronChan/.docker/machine/certs</code></p></li></ol><p>配置好，我们就能直接能在自己的主机中 使用 虚拟机中的 Docker API。</p><h2 id="一些其他的问题解决"><a href="#一些其他的问题解决" class="headerlink" title="一些其他的问题解决"></a>一些其他的问题解决</h2><h3 id="更改Docker-默认镜像路径"><a href="#更改Docker-默认镜像路径" class="headerlink" title="更改Docker 默认镜像路径"></a>更改Docker 默认镜像路径</h3><p>一般的我们系统盘不会给很大的空间，然而 Docker 镜像占用的空间一般都是非常大的，所以我们需要将镜像和容器挂在到其他数据盘下。</p><p>docker 默认的数据目录都在<code>/var/lib/docker/</code> 下，我们只要将这个目录挂载到其他数据盘目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前提关闭 docker </span></span><br><span class="line"><span class="comment"># 1. 数据盘中新建一个目录，用于存放docker数据</span></span><br><span class="line"><span class="comment"># 2. 将原数据目录移动到新建的目录中</span></span><br><span class="line"><span class="comment"># 3. 创建软链接，将数据盘中的docker数据目录挂到/var/lib/docker/</span></span><br><span class="line"><span class="comment"># 4. 重启 docker 查询 Docker 信息</span></span><br><span class="line"><span class="comment"># 查询到结果 ‘Docker Root Dir: /media/kronchan/文件/kronchan/tools/docker’</span></span><br></pre></td></tr></table></figure><h3 id="WARNING-No-memory-limit-support"><a href="#WARNING-No-memory-limit-support" class="headerlink" title="WARNING: No memory limit support"></a>WARNING: No memory limit support</h3><p>查询 <code>sudo docker info</code>的时候发现警告信息：<code>WARNING: No memory limit support</code>。</p><p>解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># 加入 GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"</span></span><br><span class="line"><span class="comment"># 更新 grub</span></span><br><span class="line">$ sudo grub-update</span><br><span class="line">sudo: grub-update：找不到命令</span><br><span class="line">$ sudo update-grub</span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found theme: /boot/grub/themes/deepin/theme.txt</span><br><span class="line">Found background image: /boot/grub/themes/deepin/background.png</span><br><span class="line">Found linux image: /boot/vmlinuz-4.9.0-deepin13-amd64</span><br><span class="line">Found initrd image: /boot/initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">Found deepin image: /boot/deepin/vmlinuz-4.13.4</span><br><span class="line">Found initrd image: /boot/deepin/initrd.img-4.13.4</span><br><span class="line">Adding boot menu entry <span class="keyword">for</span> EFI firmware configuration</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 重启系统，然后检查查看问题是否存在</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Documentation</a></li><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" rel="external nofollow noopener noreferrer" target="_blank">Docker — 从入门到实践</a></li><li><a href="http://www.widuu.com/docker/index.html" rel="external nofollow noopener noreferrer" target="_blank">Docker 中文指南</a></li><li><a href="https://deepzz.com/post/dockerd-and-docker-remote-api.html" rel="external nofollow noopener noreferrer" target="_blank">远程连接docker daemon，Docker Remote API</a></li><li><a href="https://yq.aliyun.com/articles/91396" rel="external nofollow noopener noreferrer" target="_blank">优雅地实现安全的容器编排 - Docker Secrets</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;学习总结来自 Gitbook &lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/basic_concept/image.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Docker 从入门到实践的总结&lt;/a&gt;；&lt;br&gt;现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。&lt;/p&gt;&lt;p&gt;这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 &lt;em&gt;shell&lt;/em&gt; 脚本基础学习起来时要轻松很多，重点是理解原理，有条件加以实战，才知道原来是这样啊，也能发现发现很多问题。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://blog.wuwii.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 安装 Jenkins</title>
    <link href="http://blog.wuwii.com/docker-jenkins.html"/>
    <id>http://blog.wuwii.com/docker-jenkins.html</id>
    <published>2018-04-09T14:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>jenkins是一个用Java编写的开源自动化服务器,它是Hudson的一个分支project ; 它是一个持续集成软件(continuous integration),它以节点为单位,连接整个工作流, 通过各种类型插件支持构成具有个性化要求的项目持续集成, 通过各种各样的插件(plugin)来实现各个节点的功能, 它们共同完成持续集成(自动部署)/自动测试或者持续交付等工作.</p></blockquote><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>直接从 DockerHub 上pull 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins</span><br></pre></td></tr></table></figure></li><li><p>由于 Jenkins 容器运行后，会自动在宿主计算机中挂在一个数据卷 <code>var/jenkins_home</code>，我们在主机中可以新建一个数据卷的文件夹，这里注意的是，有权限问题，不然会启动失败，有点坑这里，卡了半天，给宿主的这个挂载卷目录中加上下面的权限的就好了，改成为uid 1000的用户，具体参考阿里云<a href="https://yq.aliyun.com/articles/53990" rel="external nofollow noopener noreferrer" target="_blank">谈谈 Docker Volume 之权限管理（一）</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /var/jenkins_home</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 7322:8080 -p 50000:50000 -v /var/jenkins_home/:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure></li></ol><ul><li>8080 端口是访问 jenkins 网页的端口，如果你想在 80 端口访问，就改成 -p 80:8080</li><li><p>50000 端口与 slave 有关，主要作为master的jenkins用来连接slave的。</p><p>可以更改挂载卷的目录，不过记得也要设置目录权限的问题。</p><p>使用 <code>docker ps</code> 查看运行的容器。</p><h3 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h3></li></ul><ol><li><p>使用 host + port 访问 jenkins，会进入第一个页面：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/docker/jenkins-1.png" alt="image"></p><p>因为我们将目录<code>/var/jenkins_home</code>已经挂载在宿主主机，可以直接去这个目录查看密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> cat /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line">688293f8bfd843c4b87398b4d910f506</span><br></pre></td></tr></table></figure></li><li><p>进入后就开始安装插件的过程，然后等待安装完成。</p></li><li>然后跳出一个页面设置账号和密码，这样就安装完成，后面学习使用 jenkins 运用到工作中。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;jenkins是一个用Java编写的开源自动化服务器,它是Hudson的一个分支project ; 它是一个持续集成软件(continuous integration),它以节点为单位,连接整个工作流, 通过各种类型插件支持构成具有个性化要求的项目持续集成, 通过各种各样的插件(plugin)来实现各个节点的功能, 它们共同完成持续集成(自动部署)/自动测试或者持续交付等工作.&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://blog.wuwii.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>TCP IP 学习笔记</title>
    <link href="http://blog.wuwii.com/tcp-ip.html"/>
    <id>http://blog.wuwii.com/tcp-ip.html</id>
    <published>2018-04-09T14:11:03.000Z</published>
    <updated>2019-12-15T15:02:50.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="为什么需要TCP-IP协议"><a href="#为什么需要TCP-IP协议" class="headerlink" title="为什么需要TCP/IP协议"></a>为什么需要TCP/IP协议</h4><p>电脑运行着不同的操作系统，想发送不同的信息出去，好像就是全国各地的方言一样，即使表达相同的意思，也不能理解它们，需要使用一个通用的方式，让两个语言不同的人能够就行交流。<br>所以它们需要一些相通的东西进行交流，所以普通话就产生了，呸，跑题了，所以TCP/IP 就这样诞生了。</p><a id="more"></a><p>TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就学会了普通话，可以和全国各地的人交流了。</p><h4 id="TCP-IP协议分层"><a href="#TCP-IP协议分层" class="headerlink" title="TCP/IP协议分层"></a>TCP/IP协议分层</h4><p>TCP工作在网络OSI的七层模型中如下所示：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/tcp-ip/1.png" alt="image"></p><ol><li><code>应用层</code>：向用户提供一组常用的应用程序，如电子邮件（简单邮件传输协议，SMTP），文件传输访问（文件传输协议，FTP），远程登录（TELNET）等。</li><li><code>传输层</code>：提供应用程序间的通信。其功能包括： 格式化信息流；提供可靠传输。</li><li><code>网络层（网际层）</code>：这里有 IP 协议类似的协议，负责相邻计算机之间的通信。功能主要包括三方面：<ol><li><strong>处理来自传输层的分组发送请求</strong>：收到请求之后，将分组装入 IP 数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口；</li><li><strong>处理输入数据报：首先检查其合法性，然后进行寻址</strong>：如果该数据包已经到达信宿机，则去掉报头，将剩下一部分交给适当的传输协议；如果该数据包尚未到达信宿机，则转发该数据报；</li><li><strong>处理路径、流控、拥塞等问题</strong>；</li></ol></li><li><code>网络接口层</code>：这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，数据传输做准备。</li><li><code>硬件层</code>：这个层次的定义包括网线的制式，网卡的定义等等</li></ol><h4 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h4><ol><li><code>ip 地址</code>：互联网地址，网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</li><li><code>域名系统</code>：域名系统是一个分布的数据库，它提供将主机名转换成IP地址的服务。</li><li><code>RFC</code>：tcp/ip协议的标准文档；</li><li><code>端口号</code>：用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。</li></ol><h3 id="TCP-的报文格式"><a href="#TCP-的报文格式" class="headerlink" title="TCP 的报文格式"></a>TCP 的报文格式</h3><p>参考<a href="https://zhangbinalan.gitbooks.io/protocol/content/tcpbao_wen_ge_shi.html" rel="external nofollow noopener noreferrer" target="_blank">TCP报文格式</a></p><ul><li><code>Source Port, Destination Port（源端口号，目的端口号）</code>：分别占用 16 位，用于区别主机中的不同进程；由于 IP 地址用来区分不同主机，所以源端口号、目的端口号与 IP 首部中的源 IP 地址和目的 IP 地址，技能确定唯一的一个 TCP 连接；</li><li><code>Sequence Number（发送序号）</code>：32 位数据，用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号，主要用来解决网络报乱序问题；</li><li><code>Acknowledgment Number（确认序号）</code>：占用 32 位，由接收端的计算机使用，将分段的报文重组成最初形式；如果设置了控制位 ACK = 1，则这个值表示下一个准备接受的包的序列码；</li><li><code>Offset（数据偏移量）</code>：占用 4 位，给出首部中 32bit 字的数目，需要这个值是因为任选字段的长度是可变的（如果没有任选字段，正常的长度是 20 字节）；</li><li><code>Reserved（保留位）</code>：占用 6 位，且必须是 0，为了将来定义新的用途而保留；</li><li><code>TCP Flags（TCP 标志位）</code><br>：用于标志 TCP 的某些状态，它们中的多个可同时被设置为 1，主要用于操控 TCP 的状态机，6 个标志位依次为 URG, ACK, PSH, RST, SYN, FIN。每个标志位的意义如下：</li></ul><ul><li><code>URG</code>：紧急标志 (Urgent)，该标志表示 TCP 包的紧急指针域有效（后面将会说到紧急指针域的内容），用来保证 TCP 连接不被中断，并督促中间层设备要尽快处理这些数据；</li><li><code>ACK</code>：确认标志 (Acknowledge)，该标志表示应答域有效，就是说前面提到的 TCP 应答信号会包含在 TCP 数据包中；ACK 可以由两个取值( 0/1 )：应答域有效为1，反之为0；</li><li><code>PSH</code>：推标志 (Push)，表示 Push 操作，即在数据报到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li><li><code>RST</code>：复位标志 (Reset)，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据报；</li><li><code>SYN</code>：同步标志 (Synchronize)，用来建立连接。该标志经常与 ACK 标志搭配使用。</li></ul><ul><li><code>FIN</code>：结束标志 (Finish)，表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描；</li></ul><p>参考<a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/77942066" rel="external nofollow noopener noreferrer" target="_blank">TCP 协议详解</a></p><h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/tcp-ip/2.png" alt="image"></p><p>三次握手详解 TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP / IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。 三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。这就是面试中经常会被问到的 TCP 三次握手。</p><p>参考<a href="https://github.com/jawil/blog/issues/14" rel="external nofollow noopener noreferrer" target="_blank">通俗大白话来理解TCP协议的三次握手和四次分手</a></p><p>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；<br>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置A<code>cknowledgment Number为x+1(Sequence Number+1)；</code>同时，自己自己还要发送SYN请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入<code>SYN_RECV</code>状态；<br>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。</p><p>主要是注意为什么要进行第三次连接，这里很容易挖坑，书中解释说：</p><blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p></blockquote><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求报文段后，就误认为是客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要服务器发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的运输连接已经建立，并一直等待客户端发来数据。这样，服务器的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，客户端不会向服务器的确认发出确认。服务器由于收不到确认，就知道客户端并没有要求建立连接。”</p></blockquote><p><strong>其实主要目的就是为了防止服务端一致等待导致资源浪费。</strong></p><h3 id="TCP-的四次分手"><a href="#TCP-的四次分手" class="headerlink" title="TCP 的四次分手"></a>TCP 的四次分手</h3><p>具体还是参考上面提供的这个链接<a href="https://github.com/jawil/blog/issues/14" rel="external nofollow noopener noreferrer" target="_blank">通俗大白话来理解TCP协议的三次握手和四次分手</a></p><p>第一次分手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机2发送一个FIN报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；<br>第三次分手：主机2向主机1发送<code>FIN</code>报文段，请求关闭连接，同时主机2进入<code>CLOSE_WAIT</code>状态；<br>第四次分手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待<code>2MSL</code>后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><ul><li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li><code>TIME_WAIT</code>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li><li><code>CLOSED</code>: 表示连接中断。</li></ul><hr><p>了解了基础，好好整理下，面试时候该要上场的。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>三次握手和四次挥手的流程上面已经提过了。</p><ul><li><p>TCP协议和UDP协议的区别是什么？</p><ul><li>TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的</li><li>TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。</li><li>TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。</li><li>TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率</li><li>TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。</li><li>TCP面向的是字节流的服务，UDP面向的是报文的服务。</li></ul></li><li><p>为什么要三次握手，两次，四次行不行？</p><p>三次握手：<br>“喂，你听得到吗？”<br>“我听得到呀，你听得到我吗？”<br>“我能听到你，今天balabala……”<br>​</p><p>两次握手：<br>“喂，你听得到吗？”<br>“我听得到，你听得到吗？”<br>‘’今天balabala………‘’<br>“……谁在说话？”<br>“……”<br>​</p><p>四次握手：<br>“喂，你听得到吗？”<br>“我听得到呀，你听得到我吗？”<br>“我能听到你，你能听到我吗？”<br>“……不想跟傻逼说话”</p><p>(摘自知乎)<br>总的来说就是三次刚好，多一次浪费；少一次不够，会让服务端一直等待发送消息，白白浪费了资源。</p></li><li><p>四次挥手释放连接时，等待2MSL的意义？</p><p>假设 A 是客户端， B 是服务端</p><ul><li>第一，为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。</li><li>第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li></ul></li><li><p>常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？</p><ul><li><p>以下应用一般或必须用udp实现？</p></li><li><ul><li>多播的信息一定要用udp实现，因为tcp只支持一对一通信。</li><li>如果一个应用场景中大多是简短的信息，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。</li><li>如果一个应用场景重性能甚于重完整性和安全性，那么适合于udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用udp</li><li>如果要求快速响应，那么udp听起来比较合适</li><li>如果又要利用udp的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了。</li><li>常见的使用udp的例子：ICQ,QQ的聊天模块。</li></ul></li><li><p>以qq为例的一个说明</p><blockquote><p>登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说：</p><p>1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。</p><p>2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。</p><p>3.如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。</p></blockquote><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/tcp-ip/5.png" alt="image"></p></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h4 id=&quot;为什么需要TCP-IP协议&quot;&gt;&lt;a href=&quot;#为什么需要TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;为什么需要TCP/IP协议&quot;&gt;&lt;/a&gt;为什么需要TCP/IP协议&lt;/h4&gt;&lt;p&gt;电脑运行着不同的操作系统，想发送不同的信息出去，好像就是全国各地的方言一样，即使表达相同的意思，也不能理解它们，需要使用一个通用的方式，让两个语言不同的人能够就行交流。&lt;br&gt;所以它们需要一些相通的东西进行交流，所以普通话就产生了，呸，跑题了，所以TCP/IP 就这样诞生了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="tcp" scheme="http://blog.wuwii.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>学习 Spring Cloud：（一）Eureka  服务发现与注册</title>
    <link href="http://blog.wuwii.com/eureka-server.html"/>
    <id>http://blog.wuwii.com/eureka-server.html</id>
    <published>2018-04-06T14:11:03.000Z</published>
    <updated>2019-12-15T15:02:50.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h3><blockquote><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p></blockquote><a id="more"></a><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><p>我使用的是Spring Cloud Eureka来实现服务治理。使用版本都是2.0版本：</p><ul><li>Spring Boot 2.0</li><li>Spring Cloud Finchley.M9</li></ul><blockquote><p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p></blockquote><h4 id="创建服务注册中心"><a href="#创建服务注册中心" class="headerlink" title="创建服务注册中心"></a>创建服务注册中心</h4><ol><li><p>使用 IDEA 创建一个 <code>Spring initializr</code> 工程，勾选 <code>Cloud Discovery</code>下面的 <code>Eureka Server</code>，直接创建应用，我是用 maven 构建的，加入的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，相比较 1.X 版本中，netflix 公司的开源项目，都加了个前缀。</p></li></ol><ol><li><p>在程序启动入口加上注解 <code>@EnableEurekaServer</code> ，通过这样的注解配置，提供一个服务注册中心给其他服务进行对话。</p></li><li><p>在配置文件中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下 eureka 会将自己注册一个客户端，服务端不需要，所以我们将它关闭。</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不注册自己本身</span></span><br></pre></td></tr></table></figure></li><li><p>我们尝试访问这个应用，我设置的端口是 <code>1001</code>，所以访问 <code>http://localhost:1001</code>，访问到 Eureka 的管理注册服务的页面，可以查看各个服务的状态。</p></li></ol><h4 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h4><ol><li><p>创建一个服务提供者工程 <code>eureka-producer</code>，现在我们加入的是客户端的依赖就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后再程序启动类加上注解 <code>@EnableDiscoveryClient</code> ，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。</p></li><li><p>配置文件中加上需要注册到的服务中心的地址（指定应用程序的名称，后期进行服务路由和负载均衡时候方便调用）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-producer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://k.wuwii.com:1001/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>启动应用，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-04-04 23:53:47.436  INFO 1364 --- [  restartedMain] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1522857227434 with initial instances count: 4</span><br><span class="line">2018-04-04 23:53:47.440  INFO 1364 --- [  restartedMain] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application eureka-producer with eureka with status UP</span><br><span class="line">2018-04-04 23:53:47.441  INFO 1364 --- [  restartedMain] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1522857227440, current=UP, previous=STARTING]</span><br><span class="line">2018-04-04 23:53:47.442  INFO 1364 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-PRODUCER/localhost:eureka-producer:1002: registering service...</span><br><span class="line">2018-04-04 23:53:47.494  INFO 1364 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-PRODUCER/localhost:eureka-producer:1002 - registration status: 204</span><br></pre></td></tr></table></figure><p>上面显示我的注册服务有四个实例，我之前已经注册过了，现在服务发现 <code>localhost:eureka-producer:1002</code>，注册到服务中心成功返回状态吗204。</p><p>我们再进入到<code>http://localhost:1001</code>，可以查看到 <code>eureka-producer</code> 已经注册到我们的服务中心，</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/spring-cloud/eureka-producer-1.png" alt="image"></p></li></ol><h4 id="复杂配置"><a href="#复杂配置" class="headerlink" title="复杂配置"></a>复杂配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">    client:</span></span><br><span class="line"><span class="comment">#healthcheck:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line"><span class="attr">registry-fetch-interval-seconds:</span> <span class="number">10000</span> <span class="comment">#间隔多久去拉取服务注册信息，默认为30秒</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">  defaultZone:</span> <span class="attr">http://localhost:9000/eureka/</span></span><br><span class="line"><span class="attr"> instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">instance-id:</span> <span class="string">$&#123;spring.application.name&#125;-$&#123;eureka.instance.ip-address&#125;-$&#123;server.port&#125;-$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">10000</span>   <span class="comment">#租期更新时间间隔（默认30秒）</span></span><br><span class="line"><span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">30000</span> <span class="comment"># 租期到期时间（默认90秒）</span></span><br><span class="line"><span class="comment">#需要增加下面配置，告诉注册中心访问路径变化</span></span><br><span class="line"><span class="attr">status-page-url-path:</span> <span class="string">/actuator/info</span></span><br><span class="line"><span class="attr">health-check-url-path:</span> <span class="string">/actuator/health</span></span><br><span class="line"><span class="attr">home-page-url-path:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/learn-spring-cloud/tree/master/eureka" rel="external nofollow noopener noreferrer" target="_blank">代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;Spring-Cloud简介&quot;&gt;&lt;a href=&quot;#Spring-Cloud简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud简介&quot;&gt;&lt;/a&gt;Spring Cloud简介&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。&lt;/p&gt;&lt;p&gt;Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Cloud" scheme="http://blog.wuwii.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十七）Spring Boot 2.0 中使用 Actuator</title>
    <link href="http://blog.wuwii.com/springboot-actuator.html"/>
    <id>http://blog.wuwii.com/springboot-actuator.html</id>
    <published>2018-04-02T14:08:16.000Z</published>
    <updated>2019-12-15T15:02:50.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是完成微服务的监控，完成监控治理。可以查看微服务间的数据处理和调用，当它们之间出现了异常，就可以快速定位到出现问题的地方。</p><ul><li>springboot - version: 2.0</li></ul><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>maven 项目 在 <code>pom.xml</code> 文件中加入 actuator 的依赖：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>使用 Gradle 构建：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">compile(&quot;org.springframework.boot:spring-boot-starter-actuator&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>需要注意的是 Spring Boot 2.0 相对于上个版本， Actuator 发生很多变化，</p><h5 id="keys-的配置改变"><a href="#keys-的配置改变" class="headerlink" title="keys 的配置改变"></a>keys 的配置改变</h5><table><thead><tr><th>旧的属性</th><th>新的属性</th></tr></thead><tbody><tr><td><code>endpoints.&lt;id&gt;.*</code></td><td><code>management.endpoint.&lt;id&gt;.*</code></td></tr><tr><td><code>endpoints.cors.*</code></td><td><code>management.endpoints.web.cors.*</code></td></tr><tr><td><code>endpoints.jmx.*</code></td><td><code>management.endpoints.jmx.*</code></td></tr><tr><td><code>management.address</code></td><td><code>management.server.address</code></td></tr><tr><td><code>management.context-path</code></td><td><code>management.server.servlet.context-path</code></td></tr><tr><td><code>management.ssl.*</code></td><td><code>management.server.ssl.*</code></td></tr><tr><td><code>management.port</code></td><td><code>management.server.port</code></td></tr></tbody></table><h5 id="基本路径"><a href="#基本路径" class="headerlink" title="基本路径"></a>基本路径</h5><ol><li><p>所有 endpoints 默认情况下都已移至 <code>/actuator</code>。就是多了跟路径 <code>actuator</code> ；</p></li><li><p>上个版本中的 <code>management/context-path:</code> 和 <code>management/port:</code> 改为 :</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8004</span></span><br><span class="line"><span class="attr">    servlet:</span></span><br><span class="line"><span class="attr">      context-path:</span> <span class="string">/xxx</span> <span class="comment"># 只有在设置了 management.server.port 时才有效</span></span><br></pre></td></tr></table></figure><p>另外，您还可以使用新的单独属性 <code>management.endpoints.web.base-path</code> 为管理端点设置基本路径。</p><p>例如，如果你设置<code>management.server.servlet.context-path=/management</code>和<code>management.endpoints.web.base-path=/application</code>，你就可以在下面的路径到达终点健康：<code>/management/application/health</code>。</p><p>如果你想恢复 1.x 的行为（即具有<code>/health</code>代替<code>/actuator/health</code>），设置以下属性：<code>management.endpoints.web.base-path=/</code></p></li></ol><h5 id="ENDPOINTS"><a href="#ENDPOINTS" class="headerlink" title="ENDPOINTS"></a>ENDPOINTS</h5><p>1.X 的时候属性：</p><table><thead><tr><th>HTTP 方法</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>/autoconfig</td><td>提供了一份自动配置报告，记录哪些自动配置条件通过了，哪些没通过</td></tr><tr><td>GET</td><td>/configprops</td><td>描述配置属性(包含默认值)如何注入Bean</td></tr><tr><td>GET</td><td>/beans</td><td>描述应用程序上下文里全部的Bean，以及它们的关系</td></tr><tr><td>GET</td><td>/dump</td><td>获取线程活动的快照</td></tr><tr><td>GET</td><td>/env</td><td>获取全部环境属性</td></tr><tr><td>GET</td><td>/env/{name}</td><td>根据名称获取特定的环境属性值</td></tr><tr><td>GET</td><td>/health</td><td>报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</td></tr><tr><td>GET</td><td>/info</td><td>获取应用程序的定制信息，这些信息由info打头的属性提供</td></tr><tr><td>GET</td><td>/mappings</td><td>描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</td></tr><tr><td>GET</td><td>/metrics</td><td>报告各种应用程序度量信息，比如内存用量和HTTP请求计数</td></tr><tr><td>GET</td><td>/metrics/{name}</td><td>报告指定名称的应用程序度量值</td></tr><tr><td>POST</td><td>/shutdown</td><td>关闭应用程序，要求endpoints.shutdown.enabled设置为true</td></tr><tr><td>GET</td><td>/trace</td><td>提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</td></tr></tbody></table><p>2.0 部分更改：</p><table><thead><tr><th>1.x 端点</th><th>2.0 端点（改变）</th></tr></thead><tbody><tr><td><code>/actuator</code></td><td>不再可用。 但是，在 <code>management.endpoints.web.base-path</code> 的根目录中有一个映射，它提供了到所有暴露端点的链接。</td></tr><tr><td><code>/auditevents</code></td><td>该<code>after</code>参数不再需要</td></tr><tr><td><code>/autoconfig</code></td><td>重命名为 <code>/conditions</code></td></tr><tr><td><code>/docs</code></td><td>不再可用</td></tr><tr><td><code>/health</code></td><td>现在有一个 <code>management.endpoint.health.show-details</code> 选项 <code>never</code>, <code>always</code>, <code>when-authenticated</code>，而不是依靠 <code>sensitive</code> 标志来确定 <code>health</code> 端点是否必须显示全部细节。 默认情况下，<code>/actuator/health</code>公开并且不显示细节。</td></tr><tr><td><code>/trace</code></td><td>重命名为 <code>/httptrace</code></td></tr></tbody></table><p>默认端点 path 前面多了一级 <code>/actuator</code> 。</p><p><strong>同时注意只有端点<code>/health</code>和<code>/info</code>端点是暴露的。</strong></p><table><thead><tr><th>Property</th><th>Default</th></tr></thead><tbody><tr><td><code>management.endpoints.jmx.exposure.exclude</code></td><td></td></tr><tr><td><code>management.endpoints.jmx.exposure.include</code></td><td><code>*</code></td></tr><tr><td><code>management.endpoints.web.exposure.exclude</code></td><td></td></tr><tr><td><code>management.endpoints.web.exposure.include</code></td><td><code>info, health</code></td></tr></tbody></table><ol><li>您可以按如下方式公开所有端点：<code>management.endpoints.web.exposure.include=*</code></li><li>您可以通过以下方式显式启用<code>/shutdown</code>端点：<code>management.endpoint.shutdown.enabled=true</code></li><li>要公开所有（已启用）网络端点除<code>env</code>端点之外：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env</span><br></pre></td></tr></table></figure><p>例如：</p><p>我现在开启所有的端点：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span> <span class="comment"># * 在yaml 文件属于关键字</span></span><br></pre></td></tr></table></figure><p>执行 <code>localhost:${port}/actuator</code>，可以看到所有可以执行查看的端点监控的 Url，然后我们尝试执行关闭应用进程的指令：<code>shutdown</code>：</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-actuator/shotdown.png" alt="image"></p><h5 id="端点格式"><a href="#端点格式" class="headerlink" title="端点格式"></a>端点格式</h5><ol><li><code>/actuator/mappings</code> 端点大改变<br>JSON 格式已经更改为现在正确地包含有关上下文层次结构，多个<code>DispatcherServlets，</code>部署的 Servlet 和 Servlet 过滤器的信息。详情请参阅<a href="https://github.com/spring-projects/spring-boot/issues/9979#issuecomment-357930821" rel="external nofollow noopener noreferrer" target="_blank">＃9979</a>。<br>Actuator API 文档的<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html/#mappings" rel="external nofollow noopener noreferrer" target="_blank">相关部分</a>提供了一个示例文档。</li></ol><ol start="2"><li><code>/actuator/httptrace</code> 端点大改变<br>响应的结构已经过改进，以反映端点关注跟踪 HTTP 请求 - 响应交换的情况。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要是 Spring Boot 2.0 版本升级在 Actuator 上面有许多改动，需要记录下。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" rel="external nofollow noopener noreferrer" target="_blank">Part V. Spring Boot Actuator: Production-ready features</a></li><li><a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" rel="external nofollow noopener noreferrer" target="_blank">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要是完成微服务的监控，完成监控治理。可以查看微服务间的数据处理和调用，当它们之间出现了异常，就可以快速定位到出现问题的地方。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;springboot - version: 2.0&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>使用 Fork Join 框架</title>
    <link href="http://blog.wuwii.com/fork-join.html"/>
    <id>http://blog.wuwii.com/fork-join.html</id>
    <published>2018-03-21T15:11:03.000Z</published>
    <updated>2019-12-15T15:02:50.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当需要执行大量的小任务的时候，我们需要将多个小任务进行拆分，类似 <code>快速排序</code> 的 <code>分而治之</code>。</p><p><code>Fork</code> 将一个大任务进行递归，不断的把它切割成符合条件的小任务，然后这些子任务分配到不同 CPU 核心上去分别计算，提高效率，<code>Join</code> 是 获取到小任务的计算结果，最后合并返回。</p><p>它充分利用了现在多核 CPU 的性能。</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><code>Fork/Join</code>框架的核心类是<code>ForkJoinPool</code>，它能够接收一个<code>ForkJoinTask</code>，并得到计算结果。<code>ForkJoinTask</code>有两个子类，<code>RecursiveTask</code>（有返回值）和<code>RecursiveAction</code>（无返回结果），我们自己定义任务时，只需选择这两个类继承即可。</p><h4 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有返回值的 fork / join 任务框架</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    PrintTask(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintTask task = <span class="keyword">new</span> PrintTask(<span class="number">0</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 分配四个线程给它</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">        pool.execute(task);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (THRESHOLD &gt;= (end - start)) &#123;</span><br><span class="line">            <span class="comment">// 满足小任务条件，分配打印任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务还能继续拆分</span></span><br><span class="line">            <span class="keyword">int</span> division = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            PrintTask task1 = <span class="keyword">new</span> PrintTask(start, division);</span><br><span class="line">            PrintTask task2 = <span class="keyword">new</span> PrintTask(division, end);</span><br><span class="line">            invokeAll(task1, task2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask<t></t></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值的 fork / join 任务框架 RecursiveTask&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> works = <span class="number">200</span>;</span><br><span class="line">        SumTask task = <span class="keyword">new</span> SumTask(<span class="number">0</span>, works);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> result = forkJoinPool.invoke(task);</span><br><span class="line">        <span class="keyword">long</span> consumeTime = System.currentTimeMillis() - beginTime;</span><br><span class="line">        System.out.println(<span class="string">"Fork Join calculated the result is "</span> + result + <span class="string">",consume "</span> + consumeTime + <span class="string">"ms"</span>);</span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; works; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        consumeTime = System.currentTimeMillis() - beginTime;</span><br><span class="line">        System.out.println(<span class="string">"The correct result is "</span> + result + <span class="string">",consume "</span> + consumeTime + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (THRESHOLD &gt;= (end - start)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" result is ："</span> + sum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> division = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            SumTask task1 = <span class="keyword">new</span> SumTask(start, division);</span><br><span class="line">            SumTask task2 = <span class="keyword">new</span> SumTask(division, end);</span><br><span class="line">            invokeAll(task1, task2);</span><br><span class="line">            <span class="keyword">int</span> result1 = task1.join();</span><br><span class="line">            <span class="keyword">int</span> result2 = task2.join();</span><br><span class="line">            <span class="keyword">return</span> result1 + result2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> result is ：<span class="number">1225</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> result is ：<span class="number">8725</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> result is ：<span class="number">3725</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span> result is ：<span class="number">6225</span></span><br><span class="line">Fork Join calculated the result is <span class="number">19900</span>,consume <span class="number">50018</span>ms</span><br><span class="line">The correct result is <span class="number">19900</span>,consume <span class="number">200053</span>ms</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>我们虽然可以通过调整阈值 <code>THRESHOLD</code> 控制子任务的大小，从而控制了任务的数量，但是我们分配的 <code>Fork/Join Pool</code> 数量却是根据 CPU 性能而定的，所以，切割任务的大小和数量需要进行预先计算好，不是子任务越多就越好，而且合并结果集，需要消耗其他的计算性能。如果任务大小不能控制，可以设计可伸缩算法，动态来计算出合理的阈值，以符合要求。</li><li>注意正确的 <code>Fork/Join</code> 框架的写法，通过廖老师的文章 <a href="https://www.liaoxuefeng.com/article/001493522711597674607c7f4f346628a76145477e2ff82000" rel="external nofollow noopener noreferrer" target="_blank">Java的Fork/Join任务，你写对了吗？</a> ，指出了错误的写法的问题所在。</li></ol><p><a href="https://github.com/kaimz/learning-code/tree/master/fork-join" rel="external nofollow noopener noreferrer" target="_blank">源码地址</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;当需要执行大量的小任务的时候，我们需要将多个小任务进行拆分，类似 &lt;code&gt;快速排序&lt;/code&gt; 的 &lt;code&gt;分而治之&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Fork&lt;/code&gt; 将一个大任务进行递归，不断的把它切割成符合条件的小任务，然后这些子任务分配到不同 CPU 核心上去分别计算，提高效率，&lt;code&gt;Join&lt;/code&gt; 是 获取到小任务的计算结果，最后合并返回。&lt;/p&gt;&lt;p&gt;它充分利用了现在多核 CPU 的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://blog.wuwii.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十六）使用 RabbitMQ 消息队列</title>
    <link href="http://blog.wuwii.com/springboot-26.html"/>
    <id>http://blog.wuwii.com/springboot-26.html</id>
    <published>2018-03-19T14:08:08.000Z</published>
    <updated>2019-12-15T15:02:50.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面学习了 RabbitMQ 基础，现在主要记录下学习 Spring Boot 整合 RabbitMQ ，调用它的 API ，以及中间使用的相关功能的记录。<br><a id="more"></a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>我这里测试都是使用的是 <code>topic</code> 交换器，Spring Boot 2.0.0， jdk 1.8</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Spring Boot 版本 2.0.0<br>在 <code>pom.xml</code> 文件中引入 AMQP 的依赖<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在系统配置文件中加入连接属性<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">RabbitMQ-Demo</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">k.wuwii.com</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">kronchan</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment">#virtual-host: test</span></span><br><span class="line"><span class="attr">    publisher-confirms:</span> <span class="literal">true</span> <span class="comment"># 开启确认消息是否到达交换器，需要设置 true</span></span><br><span class="line"><span class="attr">    publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启确认消息是否到达队列，需要设置 true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h4><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p>新增一个消费者类：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReceiver</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt; receive： "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确认成功消费，否则消息会转发给其他的消费者，或者进行重试</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><p>新增 RabbitMQ 的配置类，主要是对消费者的队列，交换器，路由键的一些设置：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"springboot.demo.test1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ROUTING_KEY = <span class="string">"route-key"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGES_NAME = <span class="string">"demo-exchanges"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否持久化</span></span><br><span class="line">        <span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="keyword">boolean</span> exclusive = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="keyword">boolean</span> autoDelete = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_NAME, durable, exclusive, autoDelete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置交换器，这里我使用的是 topic exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否持久化</span></span><br><span class="line">        <span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="keyword">boolean</span> autoDelete = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(EXCHANGES_NAME, durable, autoDelete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue queue, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">container</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        container.setQueueNames(QUEUE_NAME);</span><br><span class="line">        container.setMessageListener(receiver());</span><br><span class="line">        <span class="comment">//container.setMaxConcurrentConsumers(1);</span></span><br><span class="line">        <span class="comment">//container.setConcurrentConsumers(1); 默认为1</span></span><br><span class="line">        <span class="comment">//container.setExposeListenerChannel(true);</span></span><br><span class="line">         container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">// 设置为手动，默认为 AUTO，如果设置了手动应答 basicack，就要设置manual</span></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageReceiver <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageReceiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * logger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(MessageSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// public void convertAndSend(String exchange, String routingKey, final Object object, CorrelationData correlationData)</span></span><br><span class="line">        <span class="comment">// exchange:    交换机名称</span></span><br><span class="line">        <span class="comment">// routingKey:  路由关键字</span></span><br><span class="line">        <span class="comment">// object:      发送的消息内容</span></span><br><span class="line">        <span class="comment">// correlationData:消息ID</span></span><br><span class="line">        CorrelationData correlationId = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">// ConfirmListener是当消息无法发送到Exchange被触发，此时Ack为False，这时cause包含发送失败的原因，例如exchange不存在时</span></span><br><span class="line">        <span class="comment">// 需要在系统配置文件中设置 publisher-confirms: true</span></span><br><span class="line">        <span class="keyword">if</span> (!rabbitTemplate.isConfirmListener()) &#123;</span><br><span class="line">            rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                    log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt; 消息id:&#123;&#125; 发送成功"</span>, correlationData.getId());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt; 消息id:&#123;&#125; 发送失败"</span>, correlationData.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ReturnCallback 是在交换器无法将路由键路由到任何一个队列中，会触发这个方法。</span></span><br><span class="line">        <span class="comment">// 需要在系统配置文件中设置 publisher-returns: true</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"消息id：&#123;&#125; 发送失败"</span>, message.getMessageProperties().getCorrelationId());</span><br><span class="line">        &#125;);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGES_NAME, RabbitMQConfig.ROUTING_KEY, <span class="string">"&gt;&gt;&gt;&gt;&gt; Hello World"</span>, correlationId);</span><br><span class="line">        log.info(<span class="string">"Already sent message."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试发送消息"><a href="#测试发送消息" class="headerlink" title="测试发送消息"></a>测试发送消息</h5><p>先启动系统启动类，消费者开始订阅，启动测试类发送消息。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootRabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MessageSender sender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sender.send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以在消费者接收到信息，并且发送端将打出日志 成功发送消息的记录，也可以测试下 <code>Publisher Confirms and Returns机制</code> 主要是测试 <code>ConfirmCallback</code> 和 <code>ReturnCallback</code> 这两个方法。</p><ul><li><code>ConfirmCallback</code> ，确认消息是否到达交换器，例如我们发送一个消息到一个你没有创建过的 交换器上面去，看看情况，</li><li><code>ReturnCallback</code>，确认消息是否到达队列，我们可以这样测试，定义一个路由键，不会被任何队列订阅到，最后查看结果就可以了。</li></ul><p><a href="https://github.com/kaimz/rabbitmq-prac/tree/master/springboot-rabbitmq" rel="external nofollow noopener noreferrer" target="_blank">学习源码</a></p><h4 id="使用注解的方式"><a href="#使用注解的方式" class="headerlink" title="使用注解的方式"></a>使用注解的方式</h4><h5 id="引入依赖和连接参数"><a href="#引入依赖和连接参数" class="headerlink" title="引入依赖和连接参数"></a>引入依赖和连接参数</h5><p>跟文章第一步的配置一样的。</p><h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无返回消息的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = Constant.QUEUE_NAME, durable = <span class="string">"true"</span>, exclusive = <span class="string">"false"</span>, autoDelete = <span class="string">"false"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(value = Constant.EXCHANGES_NAME, ignoreDeclarationExceptions = <span class="string">"true"</span>, type = ExchangeTypes.TOPIC, autoDelete = <span class="string">"false"</span>),</span><br><span class="line">            key = Constant.ROUTING_KEY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; receive："</span> + <span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有返回消息的</span></span><br><span class="line"><span class="comment">     * 需要注意的是，</span></span><br><span class="line"><span class="comment">     * 1. 在消息的在生产者（发送消息端）一定要使用 SendAndReceive(……) 这种带有 receive 的方法，否则会抛异常，不捕获会死循环。</span></span><br><span class="line"><span class="comment">     * 2. 该方法调用时会锁定当前线程，并且有可能会造成MQ的性能下降或者服务端/客户端出现死循环现象，请谨慎使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = Constant.QUEUE_NAME, durable = <span class="string">"true"</span>, exclusive = <span class="string">"false"</span>, autoDelete = <span class="string">"false"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(value = Constant.EXCHANGES_NAME, ignoreDeclarationExceptions = <span class="string">"true"</span>, type = ExchangeTypes.TOPIC, autoDelete = <span class="string">"false"</span>),</span><br><span class="line">            key = Constant.ROUTING_REPLY_KEY))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">receiveAndReply</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; receive："</span> + <span class="keyword">new</span> String(message));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I got the message"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是使用到 <code>@RabbitListener</code>，虽然看起来参数很多，仔细的你会发现这个和写配置类里面的基本属性是一摸一样的，没有任何区别。</p><p>需要注意的是我在这里多做了个有返回值的消息，这个使用异常的话，会不断重试消息，从而阻塞了线程。而且使用它的时候只能使用带有 <code>receive</code> 的方法给它发送消息。</p><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p>生产者没什么变化。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * logger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(MessageSender.class);</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入 RabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageSender</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试无返回消息的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        rabbitTemplate.convertAndSend(Constant.EXCHANGES_NAME, Constant.ROUTING_KEY, <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; Hello World"</span>.getBytes(), correlationData);</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Already sent message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试有返回消息的，需要注意一些问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAndReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        Object o = rabbitTemplate.convertSendAndReceive(Constant.EXCHANGES_NAME, Constant.ROUTING_REPLY_KEY, <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello World Second"</span>.getBytes(), correlationData);</span><br><span class="line">        log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#123;&#125;"</span>, Objects.toString(o));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Confirmation callback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData correlation data for the callback.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             true for ack, false for nack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           An optional cause, for nack, when available, otherwise null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt; 消息id:&#123;&#125; 发送成功"</span>, correlationData.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt; 消息id:&#123;&#125; 发送失败"</span>, correlationData.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returned message callback.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    the returned message.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode  the reply code.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText  the reply text.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   the exchange.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey the routing key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"消息id：&#123;&#125; 发送失败"</span>, message.getMessageProperties().getCorrelationId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootAnnotationApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAndReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sender.sendAndReceive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/rabbitmq-prac/tree/master/springboot-annotation" rel="external nofollow noopener noreferrer" target="_blank">学习源码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前面学习了 RabbitMQ 基础，现在主要记录下学习 Spring Boot 整合 RabbitMQ ，调用它的 API ，以及中间使用的相关功能的记录。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
      <category term="RabbitMQ" scheme="http://blog.wuwii.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>学习 RabbitMQ 的基础</title>
    <link href="http://blog.wuwii.com/rabbitmq-base.html"/>
    <id>http://blog.wuwii.com/rabbitmq-base.html</id>
    <published>2018-03-18T14:08:08.000Z</published>
    <updated>2019-12-15T15:02:50.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="Advanced Message Queuing Protocol，高级消息队列协议">[1]</span></a></sup>，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p></blockquote><p>关于学习 Rabiit 的相关笔记，学习的内容来自<a href="http://blog.720ui.com/columns/rabbitmq_action_all/" rel="external nofollow noopener noreferrer" target="_blank">RabbitMQ 实战教程 文集</a>，按照自己的思路记了个笔记。</p><p><a href="https://github.com/kaimz/rabbitmq-prac/tree/master/rabbitmq" rel="external nofollow noopener noreferrer" target="_blank">个人学习代码</a><br><a id="more"></a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h4><p>在 <code>pom.xml</code> 中加入 <code>amqp</code> 的依赖 ，它封装了对 RabbitMQ 的支持相关依赖信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>发送消息的程序。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的主机名</span></span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个队列</span></span><br><span class="line">        <span class="comment">// queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 durable ：是否持久化</span></span><br><span class="line">        <span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="comment">// 参数5 arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="comment">// basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line">        <span class="comment">// 参数1 exchange ：交换器</span></span><br><span class="line">        <span class="comment">// 参数2 routingKey ： 路由键，我们将要把消息发送到哪个队列</span></span><br><span class="line">        <span class="comment">// 参数3 props ： 消息的其他参数</span></span><br><span class="line">        <span class="comment">// 参数4 body ： 消息体</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">// 关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>等待接收消息的程序。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的主机名，默认localhost</span></span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        <span class="comment">// 设置端口， 默认 端口5672</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">// 设置 Username，默认 guest</span></span><br><span class="line">        factory.setUsername(<span class="string">"kronchan"</span>);</span><br><span class="line">        <span class="comment">// 设置 Password，默认 guest</span></span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个队列</span></span><br><span class="line">        <span class="comment">// queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 durable ：是否持久化</span></span><br><span class="line">        <span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="comment">// 参数5 arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">        <span class="comment">// 创建队列消费者</span></span><br><span class="line">        com.rabbitmq.client.Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 autoAck ： 是否自动ACK，消息应答，为true关闭它</span></span><br><span class="line">        <span class="comment">// 参数3 callback ： 消费者对象的一个接口，用来配置回调</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>执行完生产者和消费者，后消费者可以接收到到对应的消息</p><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>队列类似于邮箱。虽然消息通过 RabbitMQ 在你的应用中传递，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制的限制，它本质上是一个大的消息缓冲区。不同的生产者可以通过同一个队列发送消息，此外，不同的消费者也可以从同一个队列上接收消息。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/rabbitmq_python-two.png" alt="image"></p><h5 id="轮询调度（Round-robin-dispatching）"><a href="#轮询调度（Round-robin-dispatching）" class="headerlink" title="轮询调度（Round-robin dispatching）"></a>轮询调度（Round-robin dispatching）</h5><p>使用任务队列的有点之一就是能够轻松并行的执行任务，实际上就是多建立几个通道 <code>Channel</code> 来工作。</p><h5 id="消息应答（Message-acknowledgment）"><a href="#消息应答（Message-acknowledgment）" class="headerlink" title="消息应答（Message acknowledgment）"></a>消息应答（Message acknowledgment）</h5><p>执行一个任务可能需要几秒钟。你可能会想，如果一个消费者开始一个长期的任务，并且只有部分地完成它，会发生什么事情？使用我们当前的代码，一旦 RabbitMQ 向客户发送消息，它立即将其从内存中删除。在这种情况下，如果你杀死正在执行任务的某个工作进程，我们会丢失它正在处理的信息。我们还会丢失所有发送给该特定工作进程但尚未处理的消息。<br>但是，我们不想失去任何消息。如果某个工作进程被杀死时，我们希望把这个任务交给另一个工作进程。</p><p>但是，我们不想失去任何消息。如果某个工作进程被杀死时，我们希望把这个任务交给另一个工作进程。</p><p>为了确保消息永远不会丢失，RabbitMQ 支持消息应答。从消费者发送一个确认信息告诉 RabbitMQ 已经收到消息并已经被接收和处理，然后RabbitMQ 可以自由删除它。</p><p>如果消费者被杀死而没有发送应答，RabbitMQ 会认为该信息没有被完全的处理，然后将会重新转发给别的消费者。如果同时有其他消费者在线，则会迅速将其重新提供给另一个消费者。这样就可以确保没有消息丢失，即使工作进程偶尔也会死亡。</p><p>简单验证下，开启两个消费者，接收消息的时候，关闭一个，例外的一个消费者还是只是接收到原来它自己的那一部分消息。</p><p>完善，在其中一个消费者上面关闭自动应答机制：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span> ;  </span><br><span class="line">channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br></pre></td></tr></table></figure><p></p><p>然后，每次处理完成一个消息后，手动发送一次应答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>接收消息的时候然后异常让它中断，会发现其他的消费者会接收到其他的所有的消息。</p><h5 id="消息持久化（Message-durability）"><a href="#消息持久化（Message-durability）" class="headerlink" title="消息持久化（Message durability）"></a>消息持久化（Message durability）</h5><p>当 RabbitMQ 退出或崩溃时，将会丢失所有的队列和信息，除非你告诉它不要丢失。需要两件事来确保消息不丢失：我们需要分别将队列和消息标记为持久化。</p><p>首先，我们需要确保 RabbitMQ 永远不会失去我们的队列。为了这样做，我们需要将其声明为持久化的。</p><p>在生产者上面设置：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(<span class="string">"hello_dirable"</span>, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p></p><p>其次，我们需要标识我们的信息为持久化的。通过设置 <code>MessageProperties</code> 值为 <code>PERSISTENT_TEXT_PLAIN</code>。</p><h5 id="公平转发（Fair-dispatch）"><a href="#公平转发（Fair-dispatch）" class="headerlink" title="公平转发（Fair dispatch）"></a>公平转发（Fair dispatch）</h5><p>设置 RabbitMQ 往<strong>空闲的工作线程</strong>中发送任务，避免某些工作线程的任务过高，而部分工作线程空闲的问题。</p><p>在生产者的管道设置参数：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount) ;</span><br></pre></td></tr></table></figure><p></p><h5 id="临时队列（Temporary-queues）"><a href="#临时队列（Temporary-queues）" class="headerlink" title="临时队列（Temporary queues）"></a>临时队列（Temporary queues）</h5><p>之前，我们都是使用的队列指定了一个特定的名称。不过，对于我们的日志系统而言，我们并不关心队列的名称。我们想要接收到所有的消息，而且我们也只对当前正在传递的消息感兴趣。要解决我们需求，需要做两件事。</p><p>首先，每当我们连接到 RabbitMQ，我们需要一个新的空的队列。为此，我们可以创建一个具有随机名称的队列，或者甚至更好 - 让服务器或者，让服务器为我们选择一个随机队列名称。</p><p>其次，一旦消费者与 RabbitMQ 断开，消费者所接收的那个队列应该被自动删除。</p><p>在 Java 客户端中，我们可以使用 queueDeclare() 方法来创建一个非持久的、唯一的、自动删除的队列，且队列名称由服务器随机产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p>此时，queueName 包含一个随机队列名称。</p><h4 id="交换器（Exchanges）"><a href="#交换器（Exchanges）" class="headerlink" title="交换器（Exchanges）"></a>交换器（Exchanges）</h4><p>RabbitMQ 消息模型的核心思想是，生产者不直接发送任何消息给队列。实际上，一般的情况下，生产者甚至不知道消息应该发送到哪些队列。<br>相反的，生产者只能将信息发送到交换器。交换器是非常简单的。它一边收到来自生产者的消息，另一边将它们推送到队列。交换器必须准确知道接收到的消息如何处理。是否被添加到一个特定的队列吗？是否应该追加到多个队列？或者是否应该被丢弃？这些规则通过交换器类型进行定义。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/rabbitmq_exchanges.png" alt="image"><br>交换器一共四种类型：<code>direct</code>、<code>topic</code>、<code>headers</code>、<code>fanout</code>。</p><h5 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h5><p>将所有收到的消息广播到所有它所知道的队列。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/rabbitmq_bindings.png" alt="image"></p><ul><li><p>生产者，指定一个交换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"kronchan"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始写生产者 BIGIN</span></span><br><span class="line">        String message = <span class="string">"error log"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt; sent logs"</span>);</span><br><span class="line">        <span class="comment">// 生产者 END</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者，我们创建两个消费者，绑定我们指定的交换器和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"kronchan"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始创建消费者 BEGIN</span></span><br><span class="line">        <span class="comment">// 创建一个非持久的，唯一性，自动删除的队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换器和队列</span></span><br><span class="line">        <span class="comment">// queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 exchange ：交换器名</span></span><br><span class="line">        <span class="comment">// 参数3 routingKey ：路由键名</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="comment">// 创建消费者完成 END</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        FanoutConsumer fanoutConsumer = <span class="keyword">new</span> FanoutConsumer();</span><br><span class="line">        fanoutConsumer.execute();</span><br><span class="line">        FanoutConsumer fanoutConsumer1 = <span class="keyword">new</span> FanoutConsumer();</span><br><span class="line">        fanoutConsumer.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>先启动两个消费者注册交换器，再去启动生产者。结果是两个交换器都接收到消息。</p><h5 id="direct-直接交换"><a href="#direct-直接交换" class="headerlink" title="direct 直接交换"></a>direct 直接交换</h5><p><img src="http://7xivgs.com1.z0.glb.clouddn.com/rabbitmq_direct-exchange.png" alt="image"><br>涉及到 <code>路由键值</code>，也就是前面用的主题。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 exchange ：交换器名</span></span><br><span class="line">        <span class="comment">// 参数3 routingKey ：路由键名</span></span><br></pre></td></tr></table></figure><p></p><p>就是一个队列中有多个路由键值。</p><p>其中，第一个队列与绑定键 orange 绑定，第二个队列有两个绑定，一个绑定键为 black，另一个绑定为 green。在这样的设置中，具有 orange 的交换器的消息将被路由到队列 Q1。具有 black 或 green 的交换器的消息将转到 Q2。所有其他消息将被丢弃。</p><p>支持多重绑定<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/rabbitmq_direct-exchange-multiple.png" alt="image"><br>此外，使用相同的绑定键绑定多个队列是完全合法的。在我们的示例中，我们可以在 X 和 Q1 之间添加绑定键 black。在这种情况下，direct 类型的交换器将消息广播到所有匹配的队列 Q1 和 Q2。</p><h5 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h5><blockquote><p>使用 topic 类型的交换器，不能有任意的绑定键，它必须是由点隔开的一系列的标识符组成。标识符可以是任何东西，但通常它们指定与消息相关联的一些功能。其中，有几个有效的绑定键，例如 <code>stock.usd.nyse</code>， <code>nyse.vmw</code>， <code>quick.orange.rabbit</code>。可以有任何数量的标识符，最多可达 <strong>255</strong> 个字节。</p></blockquote><p>topic 类型的交换器和 direct 类型的交换器很类似，一个特定路由的消息将被传递到与匹配的绑定键绑定的匹配的所有队列。关于绑定键有两种有两个重要的特殊情况：</p><ul><li><code>*</code> 可以匹配一个标识符。</li><li><code>#</code> 可以匹配零个或多个标识符。</li></ul><p>例如：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/rabbitmq/1.png" alt="image"></p><p>上面我用两个消费者分别订阅了主题为 <code>*.female.*</code> 和 <code>#.asia</code> ，服务端发送两个消息，对他们进行匹配，最后获得到结果。</p><ol><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGES_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String[] TOPICS = &#123;<span class="string">"animal.female.pig"</span>, <span class="string">"man.female.asia"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"kronchan"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGES_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始写生产者 BIGIN</span></span><br><span class="line">        String message = <span class="string">"error log"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGES_NAME, TOPICS[<span class="number">0</span>], <span class="keyword">null</span>, <span class="string">"猪猪"</span>.getBytes());</span><br><span class="line">        channel.basicPublish(EXCHANGES_NAME, TOPICS[<span class="number">1</span>], <span class="keyword">null</span>, <span class="string">"亚洲女性"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt; sent logs"</span>);</span><br><span class="line">        <span class="comment">// 生产者 END</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC = <span class="string">"*.female.*"</span>; <span class="comment">// 接收所有雌性的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"k.wuwii.com"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"kronchan"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 指定一个交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始创建消费者 BEGIN</span></span><br><span class="line">        <span class="comment">// 创建一个非持久的，唯一性，自动删除的队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定交换器和队列</span></span><br><span class="line">        <span class="comment">// queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line">        <span class="comment">// 参数1 queue ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 exchange ：交换器名</span></span><br><span class="line">        <span class="comment">// 参数3 routingKey ：路由键名</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, TOPIC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="comment">// 创建消费者完成 END</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h5><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列。</p><h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><p>虽然之前我们使用消息持久化解决了服务器退出或者崩溃后造成的消息丢失的情况，但是当我们生产者发送消息的时候，中间出现了问题，消息并没有成功到达消息代理服务器，提供了两种解决方案：</p><ol><li>事务机制，</li><li>confirm模式。</li></ol><h5 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h5><p>有关事务机制的方法有三个，一般情况下需要一起配合起来使用：</p><ol><li><code>txSelect</code>用于将当前channel设置成transaction模式，</li><li><code>txCommit</code>用于提交事务，</li><li><code>txRollback</code>用于回滚事务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用事务机制的话会降低RabbitMQ的性能，可以使用下面的 Confirm 模式。</p><h5 id="Confirm模式"><a href="#Confirm模式" class="headerlink" title="Confirm模式"></a>Confirm模式</h5><p>原理</p><p>生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，消息代理服务器就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，消息代理服务器回传给生产者的确认消息中 <code>deliver-tag</code>域包含了确认消息的序列号，此外消息服务器也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。</p><p>在channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。</p><ol><li>普通confirm模式：每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。</li><li>批量confirm模式：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。</li><li>异步confirm模式：提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ol><p>测试以及使用参考 <a href="https://blog.csdn.net/u013256816/article/details/55515234" rel="external nofollow noopener noreferrer" target="_blank">RabbitMQ之消息确认机制（事务+Confirm）</a></p><h3 id="中途出现的问题"><a href="#中途出现的问题" class="headerlink" title="中途出现的问题"></a>中途出现的问题</h3><ol><li>使用自己新增的账户进去的时候，给的是管理员权限，但是使用应用程序进行登陆的时候，不能进行登陆。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.rabbitmq.client.ShutdownSignalException: connection error; protocol method: #method&lt;connection.close&gt;(reply-code=530, reply-text=NOT_ALLOWED - access to vhost '/' refused for user 'kronchan', class-id=10, method-id=40)</span><br></pre></td></tr></table></figure></li></ol><p>原因是该账户没有访问权限 <code>/</code>，进入 <code>rabbitmq</code> 机器中使用命令<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  set_permissions -p / username <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure><p></p><p>该命令使用户 <code>username</code> 具有 <code>/</code>这个 <code>virtual host</code> 中所有资源的配置、写、读权限以便管理其中的资源。<a href="http://blog.csdn.net/godspeedlaile9/article/details/50594488" rel="external nofollow noopener noreferrer" target="_blank">参考</a></p><ol start="2"><li>如果需要设置持久的队列，要持久的队列必须是目前不存在的，不然会抛出异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//The AMQP operation was interrupted: AMQP close-reason, initiated by Peer, code=406, text=&quot;PRECONDITION_FAILED</span><br><span class="line">    // - inequivalent arg &apos;durable&apos; for queue &apos;queuename&apos; in vhost &apos;/&apos;: received &apos;false&apos; but current is &apos;true&apos;&quot;,</span><br></pre></td></tr></table></figure></li></ol><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">Advanced Message Queuing Protocol，高级消息队列协议<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;&lt;p&gt;AMQP &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;Advanced Message Queuing Protocol，高级消息队列协议&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;关于学习 Rabiit 的相关笔记，学习的内容来自&lt;a href=&quot;http://blog.720ui.com/columns/rabbitmq_action_all/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;RabbitMQ 实战教程 文集&lt;/a&gt;，按照自己的思路记了个笔记。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kaimz/rabbitmq-prac/tree/master/rabbitmq&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;个人学习代码&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mq" scheme="http://blog.wuwii.com/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十五）使用 Redis 实现数据缓存</title>
    <link href="http://blog.wuwii.com/springboot-25.html"/>
    <id>http://blog.wuwii.com/springboot-25.html</id>
    <published>2018-03-17T14:08:08.000Z</published>
    <updated>2019-12-15T15:02:50.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于 Ehcache 存在于单个 java 程序的进程中，无法满足多个程序分布式的情况，需要将多个服务器的缓存集中起来进行管理，需要一个缓存的寄存器，这里使用的是 Redis。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>当应用程序要去缓存中读取数据，但是缓存中没有找到该数据，则重新去数据库中获取数据，然后将数据存入缓存中。<br>还有当我们需要更新或者删除缓存中的数据时候，需要让缓存失效。</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/springboot-cache/3.png" alt="cache"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>加入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在系统配置文件中加入 redis 的连接参数:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.19</span><span class="number">.200</span> <span class="comment"># 120.79.208.199 # host ,默认 localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span> <span class="comment"># 端口号，默认6379</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line">    <span class="comment"># 设置都是默认值，可以按需求设计</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">8</span> <span class="comment"># 可用连接实例的最大数目，默认值为8；如果赋值为-1，则表示不限制；</span></span><br><span class="line"><span class="attr">      max-idle:</span> <span class="number">8</span>  <span class="comment"># 控制一个pool最多有多少个状态为idle(空闲的)的redis实例，默认值也是8。</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="bullet">-1</span> <span class="comment"># 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="number">0</span> <span class="comment"># 控制一个pool最少有多少个状态为idle(空闲的)的redis实例，默认值为0。</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">0</span> <span class="comment"># 连接超时时间 单位 ms，默认为0</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">master</span> <span class="comment"># 密码，根据自己的 redis 设计，默认为空</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">redis</span> <span class="comment"># 设置缓存类型</span></span><br></pre></td></tr></table></figure><p>然后在系统入口启动类上面加入打开缓存的注解 <code>@EnableCaching</code>。<br>如果没启用其他缓存，这样就自动打开 redis 缓存。</p><h4 id="1-5-X-版本"><a href="#1-5-X-版本" class="headerlink" title="1.5.X 版本"></a>1.5.X 版本</h4><p>自定义注册 RedisCacheManager，设置相关参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">    <span class="comment">// 设置缓存最大时间 24 h</span></span><br><span class="line">    redisCacheManager.setDefaultExpiration(<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-0-X-版本"><a href="#2-0-X-版本" class="headerlink" title="2.0.X 版本"></a>2.0.X 版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化为默认设置</span></span><br><span class="line">        RedisCacheManager redisCacheManager = RedisCacheManager.create(factory);</span><br><span class="line">        <span class="comment">// 设置缓存最大时间</span></span><br><span class="line">        <span class="comment">/*RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();  // 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span></span><br><span class="line"><span class="comment">        config = config.entryTtl(Duration.ofMinutes(1))     // 设置缓存的默认过期时间，也是使用Duration设置</span></span><br><span class="line"><span class="comment">                .disableCachingNullValues();     // 不缓存空值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在业务层是用缓存"><a href="#在业务层是用缓存" class="headerlink" title="在业务层是用缓存"></a>在业务层是用缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"em"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(key = <span class="string">"#p0"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">findOne</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新缓存中的数据，</span></span><br><span class="line"><span class="comment">     * 由于 redis 是存在外部，不是 ehcache 那样存在于项目进程中，需要我们主动去更新 缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="meta">@CachePut</span>(key = <span class="string">"#p0.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">update</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同样主动去删除 cache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="meta">@CacheEvict</span>(key = <span class="string">"#p0"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        dao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的使用参考前面的<a href="http://blog.wuwii.com/springboot-21.html#注解的使用">学习Spring Boot：（二十一）使用 EhCache 实现数据缓存</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;!-- build time:Tue Oct 12 2021 17:39:15 
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redis" scheme="http://blog.wuwii.com/tags/redis/"/>
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中使用定时任务</title>
    <link href="http://blog.wuwii.com/spring-schedule.html"/>
    <id>http://blog.wuwii.com/spring-schedule.html</id>
    <published>2018-03-15T15:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>需要定时用于系统监控，或者做一些定时自动做一些操作，使用起来还是蛮简单的，就是配置参数需要记录下。<br><a id="more"></a><br>Spring 中自己内置的定时任务</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Spring-中使用"><a href="#Spring-中使用" class="headerlink" title="Spring 中使用"></a>Spring 中使用</h4><p>在 Spring 中使用定时任务有两种方式：</p><ul><li>注解方式；</li><li>配置文件。</li></ul><h5 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h5><p>注解方式方式配置起来非常方便，但是，如果要修改定时任务的时间计划，就需要修改源代码，</p><ol><li><p>在 <code>application.xml</code> 文件中添加开启定时任务的注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果使用的使用的 IDEA 可以自动添加配置文件的 <code>空间命名</code>、<code>xml 标签规范</code>和命名空间相应的验证文件，在 Eclipse 中将视图从 <code>source</code> 切换到 <code>Namespaces</code> 勾选自动添加相应命名空间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"</span><br></pre></td></tr></table></figure></li><li><p>新建定时任务计划，使用注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleJob</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每 2s 执行一次，</span></span><br><span class="line"><span class="comment">     * 函数不能有返回值，不然会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateScheduleJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 执行定时任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h5><ol><li><p>新建定时任务计划类，不适用任何注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleJob</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数不能有返回值，不然会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateScheduleJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 执行定时任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>application.xml</code> 中上面的给出命名空间校验地址，后在配置文件中注册相应的实体类和方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"task"</span> <span class="attr">class</span>=<span class="string">"xxx.xxx.schedule.ScheduleJob"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里表示的是每天0点执行一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"task"</span> <span class="attr">method</span>=<span class="string">"operateScheduleJob"</span> <span class="attr">cron</span>=<span class="string">"0 0 0 * * ?"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Spring-Boot-中使用"><a href="#Spring-Boot-中使用" class="headerlink" title="Spring Boot 中使用"></a>Spring Boot 中使用</h4><p>在程序启动类上面加上注解 <code>EnableScheduling</code>，表示开启定时任务功能，然后就能在程序中和上面 <code>Spring</code> 一样使用注解的方式定义定时任务。</p><h4 id="关于-Schedule-注解"><a href="#关于-Schedule-注解" class="headerlink" title="关于 @Schedule 注解"></a>关于 @Schedule 注解</h4><p><strong>它有多种定时规则表达式：</strong></p><ul><li><code>cron</code>：指定cron表达式</li><li><code>zone</code>：默认使用服务器默认时区。可以设置为<code>java.util.TimeZone</code>中的zoneId</li><li><code>fixedDelay</code>：从上一个任务完成开始到下一个任务开始的间隔，单位毫秒</li><li><code>fixedDelayString</code>：同上，时间值是String类型</li><li><code>fixedRate</code>：从上一个任务开始到下一个任务开始的间隔，单位毫秒</li><li><code>fixedRateString</code>：同上，时间值是String类型</li><li><code>initialDelay</code>：任务首次执行延迟的时间，单位毫秒</li><li><code>initialDelayString</code>：同上，时间值是String类型<h4 id="cron-表达式"><a href="#cron-表达式" class="headerlink" title="cron 表达式"></a>cron 表达式</h4>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek</li></ul><p><strong>每一个域可出现的字符如下：</strong></p><ul><li><code>Seconds</code>: 可出现 <code>, - * /</code> 四个字符，有效范围为<code>0-59</code>的整数</li><li><code>Minutes</code>: 可出现 <code>, - * /</code> 四个字符，有效范围为<code>0-59</code>的整数</li><li><code>Hours</code>: 可出现 <code>, - * /</code> 四个字符，有效范围为<code>0-23</code>的整数</li><li><code>DayofMonth</code>: 可出现 <code>, - * / ? L W C</code> 八个字符，有效范围为<code>0-31</code>的整数</li><li><code>Month</code>: 可出现 <code>, - * /</code>四个字符，有效范围为1-12的整数或<code>JAN-DEC</code></li><li><code>DayofWeek</code>: 可出现 <code>, - * / ? L C #</code> 四个字符，有效范围为<code>1-7</code>的整数或<code>SUN-SAT</code>两个范围。1表示星期天，2表示星期一， 依次类推</li><li><code>Year</code>: 可出现 <code>, - * /</code> 四个字符，有效范围为<code>1970-2099</code>年</li></ul><p><strong>每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</strong></p><ul><li><code>*</code>：表示匹配该域的任意值，假如在<code>Minutes</code>域使用<code>*</code>, 即表示每分钟都会触发事件。</li><li><code>?</code>：只能用在<code>DayofMonth</code>和<code>DayofWeek</code>两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和 DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。</li><li><code>-</code>：表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次。</li><li><code>/</code>：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次。</li><li><code>,</code>：表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。</li><li><code>L</code>：表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。</li><li><code>W</code>：表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。</li><li><code>LW</code>：这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。</li><li><code>#</code>：用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在<code>4#2</code>，表示某月的第二个星期三。</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/kaimz/learning-code/tree/master/jpa-muti-datasource" rel="external nofollow noopener noreferrer" target="_blank">Spring Task定时任务的配置和使用](https://www.jianshu.com/p/25c601f43552)</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;需要定时用于系统监控，或者做一些定时自动做一些操作，使用起来还是蛮简单的，就是配置参数需要记录下。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring" scheme="http://blog.wuwii.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十四）多数据源配置与使用</title>
    <link href="http://blog.wuwii.com/springboot-24.html"/>
    <id>http://blog.wuwii.com/springboot-24.html</id>
    <published>2018-03-15T14:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着业务量增大，可能有些业务不是放在同一个数据库中，所以系统有需求使用多个数据库完成业务需求，我们需要配置多个数据源，从而进行操作不同数据库中数据。</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="JdbcTemplate-多数据源"><a href="#JdbcTemplate-多数据源" class="headerlink" title="JdbcTemplate 多数据源"></a>JdbcTemplate 多数据源</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>需要在 Spring Boot 中配置多个数据库连接，当然怎么设置连接参数的 key 可以自己决定，</p><blockquote><p>需要注意的是 <code>Spring Boot 2.0</code> 的默认连接池配置参数好像有点问题，由于默认连接池已从 <code>Tomcat</code> 更改为 <code>HikariCP</code>，以前有一个参数 <code>url</code>，已经改成 <code>hikari.jdbcUrl</code> ，不然无法注册。我下面使用的版本是 <code>1.5.9</code>。<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8022</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">     url:</span> <span class="attr">jdbc:mysql://localhost:3306/learn?useSSL=false&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">     username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">     password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">     driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  second-datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/learn1?useSSL=false&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123457</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p></p></blockquote><h5 id="注册-DataSource"><a href="#注册-DataSource" class="headerlink" title="注册 DataSource"></a>注册 DataSource</h5><p>注册两个数据源，分别注册两个 <code>JdbcTemplate</code>，<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 data source</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"firstDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">// 有相同实例优先选择</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.second-datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"secondDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"firstJdbcTemplate"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">firstJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"secondJdbcTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">secondJdbcTemplate</span><span class="params">(@Qualifier(<span class="string">"secondDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"secondJdbcTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"DELETE FROM employee"</span>);</span><br><span class="line">        jdbcTemplate1.update(<span class="string">"DELETE FROM employee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into employee(id,name,age) VALUES (1, 'wuwii', 24)"</span>);</span><br><span class="line">        jdbcTemplate1.update(<span class="string">"insert into employee(id,name,age) VALUES (1, 'kronchan', 23)"</span>);</span><br><span class="line">        Assert.assertThat(<span class="string">"wuwii"</span>, Matchers.equalTo(jdbcTemplate.queryForObject(<span class="string">"SELECT name FROM employee WHERE id=1"</span>, String.class)));</span><br><span class="line">        Assert.assertThat(<span class="string">"kronchan"</span>, Matchers.equalTo(jdbcTemplate1.queryForObject(<span class="string">"SELECT name FROM employee WHERE id=1"</span>, String.class)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/learning-code/tree/master/jdbc-muti-datasource" rel="external nofollow noopener noreferrer" target="_blank">源码地址</a></p><h4 id="使用-JPA-支持多数据源"><a href="#使用-JPA-支持多数据源" class="headerlink" title="使用 JPA 支持多数据源"></a>使用 JPA 支持多数据源</h4><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>相比使用 <code>jdbcTemplate</code>，需要设置下 <code>JPA</code> 的相关参数即可，没多大变化：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8022</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">     url:</span> <span class="attr">jdbc:mysql://localhost:3306/learn?useSSL=false&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">     username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">     password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">     driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  second-datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/learn1?useSSL=false&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    database:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line">    <span class="comment"># update 更新表结构</span></span><br><span class="line">    <span class="comment"># create 每次启动删除上次表，再创建表，会造成数据丢失</span></span><br><span class="line">    <span class="comment"># create-drop： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</span></span><br><span class="line">    <span class="comment"># validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line"><span class="attr">        dialect:</span> <span class="string">org.hibernate.dialect.MySQLDialect</span></span><br></pre></td></tr></table></figure><p></p><p>首先一样的是我们要注册相应的 DataSource，还需要指定相应的数据源所对应的实体类和数据操作层 <code>Repository</code>的位置：</p><ul><li><p><code>firstDataSource</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(</span><br><span class="line">        entityManagerFactoryRef = <span class="string">"firstEntityManagerFactory"</span>,</span><br><span class="line">        transactionManagerRef = <span class="string">"firstTransactionManager"</span>,</span><br><span class="line">        basePackages = <span class="string">"com.wuwii.module.system.dao"</span> <span class="comment">// 设置该数据源对应 dao 层所在的位置</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"firstEntityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntityManager <span class="title">entityManager</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManagerFactoryPrimary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"firstDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">// 有相同实例优先选择，相同实例只能设置唯一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">firstDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"firstEntityManagerFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactoryPrimary</span> <span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .dataSource(firstDataSource())</span><br><span class="line">                .properties(getVendorProperties(firstDataSource()))</span><br><span class="line">                .packages(<span class="string">"com.wuwii.module.system.entity"</span>) <span class="comment">//设置该数据源对应的实体类所在位置</span></span><br><span class="line">                .persistenceUnit(<span class="string">"firstPersistenceUnit"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getVendorProperties</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jpaProperties.getHibernateProperties(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"firstTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManagerPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>secondDataSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(</span><br><span class="line">        entityManagerFactoryRef = <span class="string">"secondEntityManagerFactory"</span>,</span><br><span class="line">        transactionManagerRef = <span class="string">"secondTransactionManager"</span>,</span><br><span class="line">        basePackages = <span class="string">"com.wuwii.module.user.dao"</span> <span class="comment">// 设置该数据源 dao 层所在的位置</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"secondEntityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntityManager <span class="title">entityManager</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManagerFactoryPrimary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.second-datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"secondDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">secondDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"secondEntityManagerFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactoryPrimary</span> <span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .dataSource(secondDataSource())</span><br><span class="line">                .properties(getVendorProperties(secondDataSource()))</span><br><span class="line">                .packages(<span class="string">"com.wuwii.module.user.entity"</span>) <span class="comment">//设置该数据源锁对应的实体类所在的位置</span></span><br><span class="line">                .persistenceUnit(<span class="string">"secondPersistenceUnit"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getVendorProperties</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jpaProperties.getHibernateProperties(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"secondTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManagerPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        employeeDao.deleteAll();</span><br><span class="line">        userDao.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">"wuwii"</span>, <span class="number">24</span>);</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">"KronChan"</span>, <span class="number">24</span>);</span><br><span class="line">        userDao.save(user);</span><br><span class="line">        Assert.assertThat(employee, Matchers.equalTo(employeeDao.findOne(Example.of(employee))));</span><br><span class="line">        Assert.assertThat(user, Matchers.equalTo(userDao.findOne(Example.of(user))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/learning-code/tree/master/jpa-muti-datasource" rel="external nofollow noopener noreferrer" target="_blank">源码地址</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着业务量增大，可能有些业务不是放在同一个数据库中，所以系统有需求使用多个数据库完成业务需求，我们需要配置多个数据源，从而进行操作不同数据库中数据。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring Boot：（二十三）Spring Boot 中使用 Docker</title>
    <link href="http://blog.wuwii.com/springboot-23.html"/>
    <id>http://blog.wuwii.com/springboot-23.html</id>
    <published>2018-03-13T14:12:03.000Z</published>
    <updated>2019-12-15T15:02:50.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>简单的学习下怎么在 Spring Boot 中使用 Docker 进行构建，发布一个镜像，现在我们通过远程的 docker api 构建镜像，运行容器，发布镜像等操作。</p><p>这里只介绍两种方式：</p><ol><li>远程命令 api （需要知道 Docker 命令）</li><li>maven 插件 （不需要了解 Docker 命令）</li></ol><a id="more"></a><h3 id="开启-Docker-api-远程访问"><a href="#开启-Docker-api-远程访问" class="headerlink" title="开启 Docker api 远程访问"></a>开启 Docker api 远程访问</h3><p>开启 docker api 远程操作的功能，<br>例如，centos 7 中在 <code>/usr/lib/systemd/system/docker.service</code>，文件中，修改 <code>ExecStart</code> 的参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p></p><p>端口自定义设置即可。</p><p>重载所有修改过的配置文件，并且重启 docker，<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p></p><blockquote><p>需要注意的是，由于没有密码登陆任何权限验证，外网或者生产环境需要上证书使用。</p></blockquote><h3 id="命令方式构建镜像"><a href="#命令方式构建镜像" class="headerlink" title="命令方式构建镜像"></a>命令方式构建镜像</h3><p>这种方式其实非常简单，就是需要懂得 docker 命令，才能操作。</p><p>经过上面开启 Docker Api 后，我们可以使用网络环境操作 Docker 引擎了。</p><ol><li><p>新建 <code>Dockerfile</code> 构建镜像文件，新创建一个文件夹，专门放构建镜像需要的文件，我创建的是 <code>/src/docker/</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="bash">ADD springboot-docker.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>执行 maven 命令 ，将项目打包 <code>mvn clean package --DskipTests</code>，然后将打好的 jar 包，也放入到 <code>Dockerfile</code>项目目录中。</p></li><li><p>然后进入 <code>src/docker</code> 目录下执行 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://xxx.xxx.xxx.xxx:2375 build -t <span class="built_in">test</span> .</span><br></pre></td></tr></table></figure><p>开始构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  31.74MB</span><br><span class="line">Step 1/5 : FROM java:8</span><br><span class="line"> ---&gt; d23bdf5b1b1b</span><br><span class="line">Step 2/5 : EXPOSE 8080</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 060a43a42146</span><br><span class="line">Step 3/5 : VOLUME /tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4f88fde6181</span><br><span class="line">Step 4/5 : ADD springboot-docker.jar app.jar</span><br><span class="line"> ---&gt; 3a40188825b0</span><br><span class="line">Step 5/5 : ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> ab093916fc4c</span><br><span class="line">Removing intermediate container ab093916fc4c</span><br><span class="line"> ---&gt; 45a3966feb60</span><br><span class="line">Successfully built 45a3966feb60</span><br><span class="line">Successfully tagged <span class="built_in">test</span>:latest</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-docker-maven-plugin构建镜像"><a href="#使用-docker-maven-plugin构建镜像" class="headerlink" title="使用 docker-maven-plugin构建镜像"></a>使用 docker-maven-plugin构建镜像</h3><h4 id="在-maven-项目下加入-docker-maven-plugin"><a href="#在-maven-项目下加入-docker-maven-plugin" class="headerlink" title="在 maven 项目下加入 docker-maven-plugin"></a>在 maven 项目下加入 <code>docker-maven-plugin</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--打包docker插件相关参数的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--打包的镜像名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;project.groupId&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Dockerfile文件位置，以项目的 root 目录为根节点，建议到单独建立一个目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>./src/docker/<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Docker 远程的 API 地址及端口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://xxx.xxx.xxx.199:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行构建docker镜像的时候需要哪些文件，springboot项目指定 打包好的jar 镜像就好--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里指定的文件是target中的jar文件--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h4><p>需要跟<code>pom.xml</code> 上面配置的路径保持一致，所以我的路径是 <code>${baseProjectFolder}/src/docker</code>的文件夹下新建一个文件 <code>Dockerfile</code>，添加构建 docker 相关命令参数：<br></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp </span></span><br><span class="line"><span class="bash">ADD springboot-docker.jar app.jar <span class="comment"># 根据打包的jar 包文件名进行修改</span></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure><p></p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>在应用的根目录下执行命令（打包加 dokcer build）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean package docker:build -DskipTests</span><br></pre></td></tr></table></figure><p>比如使用我的工程，进行打包后完成了 docker 的构建的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building image com.wuwii/springboot-docker</span><br><span class="line">Step 1/5 : FROM java:8</span><br><span class="line"></span><br><span class="line"> ---&gt; d23bdf5b1b1b</span><br><span class="line">Step 2/5 : EXPOSE 8080</span><br><span class="line"></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> b7936baae57f</span><br><span class="line">Removing intermediate container b7936baae57f</span><br><span class="line"> ---&gt; 060a43a42146</span><br><span class="line">Step 3/5 : VOLUME /tmp</span><br><span class="line"></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 65e2b8ac44d3</span><br><span class="line">Removing intermediate container 65e2b8ac44d3</span><br><span class="line"> ---&gt; b4f88fde6181</span><br><span class="line">Step 4/5 : ADD springboot-docker.jar app.jar</span><br><span class="line"></span><br><span class="line"> ---&gt; aa3762cda143</span><br><span class="line">Step 5/5 : ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span><br><span class="line"></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d9f5f63b9736</span><br><span class="line">Removing intermediate container d9f5f63b9736</span><br><span class="line"> ---&gt; 622a7d1e315c</span><br><span class="line">ProgressMessage&#123;id=null, status=null, stream=null, error=null, progress=null, progressDetail=null&#125;</span><br><span class="line">Successfully built 622a7d1e315c</span><br><span class="line">Successfully tagged com.wuwii/springboot-docker:latest</span><br></pre></td></tr></table></figure><h3 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h3><ol><li><p>进入安装 docker 的主机中，使用命令查看镜像（<code>IMAGE ID</code> 和上面是一致的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls com.wuwii/springboot-docker</span><br><span class="line">REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">com.wuwii/springboot-docker   latest              622a7d1e315c        22 minutes ago      659MB</span><br></pre></td></tr></table></figure></li><li><p>运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8080:8080 --name learn  com.wuwii/springboot-docker</span><br><span class="line"></span><br><span class="line">180fe4a7ddfc10c0cf2c37649ae1628e804564bfe1594ef05840e707801e6da3</span><br></pre></td></tr></table></figure><p>监听 8080 端口，测试是否成功。</p></li></ol><h3 id="服务编排-compose"><a href="#服务编排-compose" class="headerlink" title="服务编排 compose"></a>服务编排 compose</h3><p>一般的我们的 WEB 项目会使用到很多外部工具，例如 Redis ，MYSQL, ES等，如果一个一个启动搭建部署，太麻烦了，还要测试如果把这个一套环境拿到别的地方还能用吗？</p><p>使用服务编排可以避免这些坑。</p><p>加入我们的项目中增加了 Mysql 的数据库，在根目录新建一个 <code>docker-compose.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span> <span class="comment"># 建议加上引号，如果单独两位数的数字，可能出现解析问题</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line">   <span class="comment"># build:</span></span><br><span class="line">    <span class="comment">#  context: ./src/docker # Dockerfile 文件的目录，可以远程地址，绝对 or 相对</span></span><br><span class="line">     <span class="comment"># dockerfile: Dockerfile # 如果你的 Dockerfile 重命名了，需要指定</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">test:latest</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">      DATABASE:</span> <span class="string">learn</span></span><br><span class="line"><span class="attr">      DB_USERNAME:</span> <span class="string">root</span> <span class="comment"># 测试用下 root</span></span><br><span class="line"><span class="attr">      DB_PASSWORD:</span> <span class="number">123456</span> <span class="comment">#  # 建议使用 secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">        - db_data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">learn</span></span><br><span class="line"><span class="attr">      MYSQL_USER:</span> <span class="string">kronchan</span></span><br><span class="line"><span class="attr">      MYSQL_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db_data:</span>  <span class="comment"># 使用的数据卷必须声明</span></span><br></pre></td></tr></table></figure><p>上面我使用的是前面已经构建好的镜像，然后执行的编排，更好的是直接使用 <code>build</code> 让它自己编排服务。</p><p>系统配置文件<code>application.yml</code>使用缺省值的方式，不影响开发的使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://$&#123;DB_HOST:localhost:3306&#125;/$&#123;DATABASE:learn&#125;?useSSL=false&amp;allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">$&#123;DB_USERNAME:root&#125;</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">$&#123;DB_PASSWORD:123456&#125;</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    database:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line"><span class="attr">        dialect:</span> <span class="string">org.hibernate.dialect.MySQL57Dialect</span> <span class="comment"># 方言根据 数据库版本选择吧</span></span><br></pre></td></tr></table></figure><p>也可以使用不同的 <code>spring.profiles</code>指定不同的环境，在 <code>docker-compose.yml</code> 中覆盖执行命令指定环境也是常见做法的：<code>command: mvn clean spring-boot:run -Dspring-boot.run.profiles=xxx</code></p><p>最后启动，在 <code>docker-compose.yml</code>目录下执行 ： <code>docker-compose up</code></p><p>关闭服务 <code>docker-compose down</code></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>docker-compose 顺序的问题，这个是开始学习编排的时候需要注意的问题，如果上面的服务编排中 mysql 启动的慢， web 项目就会启动失败，它启动的时候不知道被依赖的服务是否启动完成，就会出现这样的问题。</p><p>解决的办法有以下几种：</p><ul><li>足够的容错和重试机制，比如连接数据库，在初次连接不上的时候，服务消费者可以不断重试，直到连接上位置</li><li>docker-compose拆分，分成两部分部署，将要先启动的服务放在一个docker-compose中，后启动的服务放在两一个docker-compose中，启动两次，两者使用同一个网络。</li><li>同步等待，使用<code>wait-for-it.sh</code>或者其他<code>shell</code>脚本将当前服务启动阻塞，直到被依赖的服务加载完毕<br><code>wait-for-it</code>的github地址为：<a href="https://link.jianshu.com?t=https://github.com/vishnubob/wait-for-it" rel="external nofollow noopener noreferrer" target="_blank">wait-for-it</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>主要是写 Dockerfile 的时候最好单独的拿出一个文件夹来放它，我开始的时候就是直接放在项目的根路径，结果构建镜像的时候总是出现了将其他的文件也一起复制到了 Docker 目录中，WINDOW下使用 maven 插件操作这个需要注意这个上下文环境，不然很容易将一个磁盘的文件都拷贝进来了，初学者血的教训。解决办法就是单独创建一个文件夹，将需要的东西单独放置，就不用考虑这么多问题。</li></ol><p><a href="https://github.com/kaimz/learning-code/tree/master/springboot-docker" rel="external nofollow noopener noreferrer" target="_blank">代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;简单的学习下怎么在 Spring Boot 中使用 Docker 进行构建，发布一个镜像，现在我们通过远程的 docker api 构建镜像，运行容器，发布镜像等操作。&lt;/p&gt;&lt;p&gt;这里只介绍两种方式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;远程命令 api （需要知道 Docker 命令）&lt;/li&gt;&lt;li&gt;maven 插件 （不需要了解 Docker 命令）&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://blog.wuwii.com/tags/Docker/"/>
    
      <category term="Spring Boot" scheme="http://blog.wuwii.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>安装 Docker</title>
    <link href="http://blog.wuwii.com/docker-install.html"/>
    <id>http://blog.wuwii.com/docker-install.html</id>
    <published>2018-03-13T03:11:03.000Z</published>
    <updated>2019-12-15T15:02:50.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --><p>安装之前需要注意的是系统内核版本，linux内核至少在3.10版本以上，使用 command <code>uname -r</code> 查看linux内核版本。</p><a id="more"></a><h3 id="CentOS-安装"><a href="#CentOS-安装" class="headerlink" title="CentOS 安装"></a>CentOS 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装 Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># Step 4: 开启Docker服务</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span></span><br><span class="line"><span class="comment"># vim /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"><span class="comment">#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="comment"># yum list docker-ce.x86_64 --showduplicates | sort -r</span></span><br><span class="line"><span class="comment">#   Loading mirror speeds from cached hostfile</span></span><br><span class="line"><span class="comment">#   Loaded plugins: branch, fastestmirror, langpacks</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   Available Packages</span></span><br><span class="line"><span class="comment"># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span></span><br><span class="line"><span class="comment"># sudo yum -y install docker-ce-[VERSION]</span></span><br></pre></td></tr></table></figure><p>安装校验<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp12adskpuoxodbkqzjfZ:$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><p>加入开机自启<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p></p><p>docker安装教程网址</p><h3 id="ubuntu-安装"><a href="#ubuntu-安装" class="headerlink" title="ubuntu 安装"></a>ubuntu 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装 Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="comment"># apt-cache madison docker-ce</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment"># Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)</span></span><br><span class="line"><span class="comment"># sudo apt-get -y install docker-ce=[VERSION]</span></span><br></pre></td></tr></table></figure><h3 id="Window-安装"><a href="#Window-安装" class="headerlink" title="Window 安装"></a>Window 安装</h3><p>目前 win 10 pro 支持 typer-V</p><p><a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/" rel="external nofollow noopener noreferrer" target="_blank">阿里云下载</a></p><p>在 控制面板 》 程序和功能 》 启用或关闭 Window 功能中勾选上 <code>Typer-V</code> 安装并重启，并且去<a href="https://yeasy.gitbooks.io/docker_practice/content/install/windows.html" rel="external nofollow noopener noreferrer" target="_blank">官网</a>下载 Docker 的安装包。</p><blockquote><p>注意的是，网站被墙，需要翻墙，不然下载龟速，或者去国内的镜像网站下载<br>且不是 win 10 pro 或企业版，不能启动 <code>Typer-V</code> 只能使用虚拟机环境了，可以下载 <code>Docker Toolbox</code>。</p></blockquote><h3 id="Deepin-安装"><a href="#Deepin-安装" class="headerlink" title="Deepin 安装"></a>Deepin 安装</h3><p>我使用的是桌面版 15.5</p><p><code>deepin</code> 使用官方的 <code>debian</code> 安装方式是安装不成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载已经安装的 docker</span></span><br><span class="line">$ sudo apt-get remove docker docker-engine</span><br><span class="line"><span class="comment"># 2. 安装docker-ce与密钥管理与下载相关的依赖库</span></span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl python-software-properties software-properties-common</span><br><span class="line"><span class="comment"># 3. 下载并安装密钥。</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 4. 添加docker官方仓库</span></span><br><span class="line">$ sudo add-apt-repository   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian   wheezy   stable"</span></span><br><span class="line"><span class="comment"># 5. 更新仓库</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 6. 安装docker-ce</span></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h3 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h3><p><em>首先要去官网查看版本支持情况</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew search docker  <span class="comment"># 查询， 推荐使用 Homebrew 包管理软件 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew cask install docker <span class="comment"># 安装</span></span></span><br></pre></td></tr></table></figure><h3 id="国内镜像加速器"><a href="#国内镜像加速器" class="headerlink" title="国内镜像加速器"></a>国内镜像加速器</h3><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。<br>这里我配置的是阿里云的镜像加速。</p><p>获取自己的阿里云仓库的镜像 <a href="https://cr.console.aliyun.com/?spm=a2c4e.11153959.blogcont29941.9.520269d65b5sBo&amp;accounttraceid=7944ca1b-ff8f-4239-91ba-79d103b8e92e#/imageList" rel="external nofollow noopener noreferrer" target="_blank">地址</a><br>在左侧的 <code>镜像加速器</code> 中可以查看专属加速器地址 。</p><p>最新的Linux 系统 ，systemd 的系统，在 <code>/etc/docker/daemon.json</code> 中写入，例如我的:<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://2sloyw2o.mirror.aliyuncs.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后重新加载配置文件和重启<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p></p><blockquote><p>对于使用<code>Windows 10</code> 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后左侧导航菜单选择 <code>Daemon</code>。在 <code>Registry mirrors</code> 一栏中填写加速器地址， 保存后 Docker 就会重启并应用配置的镜像地址了。</p></blockquote><p>使用 Docker toolbox 的话，进入虚拟机器更改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh default </span><br><span class="line">sudo sed -i <span class="string">"s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=加速地址 |g"</span> /var/lib/boot2docker/profile </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">$ docker-machine restart default</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://yq.aliyun.com/articles/110806" rel="external nofollow noopener noreferrer" target="_blank">Docker CE 镜像源站</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" rel="external nofollow noopener noreferrer" target="_blank">镜像加速器</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Oct 12 2021 17:39:15 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;安装之前需要注意的是系统内核版本，linux内核至少在3.10版本以上，使用 command &lt;code&gt;uname -r&lt;/code&gt; 查看linux内核版本。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.wuwii.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://blog.wuwii.com/tags/Docker/"/>
    
  </entry>
  
</feed>
